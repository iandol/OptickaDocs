
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Demonstration of a command-driven setup of an Opticka Experiment.</title><meta name="generator" content="MATLAB 9.7"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2020-01-08"><meta name="DC.source" content="optickatest.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Demonstration of a command-driven setup of an Opticka Experiment.</h1><!--introduction--><p>Opticka is an object oriented framework/GUI for the Psychophysics toolbox, allowing randomised interleaved presentation of parameter varying stimuli specified in experimenter-relevant values. It is designed to work on OS X, Windows (currently no digital I/O) or Linux, and can interface via strobed words (using a cheap and very reliable LabJack) and ethernet with external harware for recording neurophysiological data. In this example, Stimulus objects (myStims class cell array), stimulus sequence variables (myTask object), and screenManager (myScreen object) are passed to the runExperiment object for final display. Opticka also has a UI (type opticka in the command window), which is a visual manager of the objects introduced here. The UI also controls other functions such as calibration, protocol loading/saving and communication with neurophysiological equipment via LabJack and ethernet. There is also an independent receptive field mapper (rfMapper) that uses mouse control to probe receptive fields and generate drawn hand maps.</p><p>The source of this file can be found at: <a href="https://github.com/iandol/opticka/blob/master/optickatest.m">https://github.com/iandol/opticka/blob/master/optickatest.m</a></p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Initial clear up of previous runs</a></li><li><a href="#2">Stimulus Initialisation</a></li><li><a href="#11">Task Initialisation</a></li><li><a href="#12">Variable 1</a></li><li><a href="#13">Variable 2</a></li><li><a href="#14">Variable 3</a></li><li><a href="#15">Randomisation</a></li><li><a href="#16">Visual Trial List</a></li><li><a href="#17">Setup screenManager Object</a></li><li><a href="#18">Setup runExperiment Object</a></li></ul></div><h2 id="1">Initial clear up of previous runs</h2><p>Make sure we start in a clean environment, not essential</p><pre class="codeinput">clear <span class="string">myStims</span> <span class="string">myTask</span> <span class="string">myScreen</span> <span class="string">rExp</span>
sca <span class="comment">%PTB screen clear all</span>
</pre><h2 id="2">Stimulus Initialisation</h2><p>These set up the 10 different stimuli. Please note that values are in degrees, cycles/deg, deg/s etc. Colour is repestend using floating point values from 0 - 1 and all objects accept an opacity (alpha) value. Each stimulus is a class object with a series of properties ('sf', 'colour' etc.) that you can set up by simply passing property name : value pairs into the stimulus class. You can also pass these in as a structure if you prefer. If you do not pass any properties, default values will be used without problems.</p><p>First we create a stimulus manager object that collects and handles groups of stimuli as if they were a single 'thing', so for example when you use the draw method on a metaStimulus, it tells each of its child stimuli to draw in order</p><pre class="codeinput">myStims = metaStimulus();
</pre><p>Stimului are made using stimulus classes. Each class inherits from baseStimulus, which has 5 abstract classes ALL stimuli must implement: [1] SETUP(screenManager) - takes a screenManager and sets up the stimulus properties ready for display. [2] DRAW() - draws the stimulus [3] ANIMATE() - for each stimulus class, animate takes speed, tf etc. and updates the position onscreen for the next flip. [4] UPDATE() - if any parameters have changed (size, position, colour etc.), then update ensures all properties are properly updated. [5] RESET() - returns the object back to its pre-setup state.</p><pre class="codeinput"><span class="comment">%The first five stimuli are gratings / gabors of varying kinds.</span>
myStims{1}=gratingStimulus(<span class="string">'sf'</span>, 1, <span class="string">'tf'</span>, 0, <span class="string">'phase'</span>, 90, <span class="string">'contrast'</span>, 0.7, <span class="string">'size'</span>, 2, <span class="string">'angle'</span>, -45,<span class="keyword">...</span>
	<span class="string">'mask'</span>, false);

myStims{2}=gaborStimulus(<span class="string">'sf'</span>, 1, <span class="string">'contrast'</span>, 0.75, <span class="string">'tf'</span>, 3, <span class="string">'size'</span>, 3, <span class="string">'angle'</span>, -70,<span class="keyword">...</span>
	<span class="string">'aspectRatio'</span>, 0.5, <span class="string">'xPosition'</span>, 5, <span class="string">'yPosition'</span>, -5);

myStims{3}=gratingStimulus(<span class="string">'sf'</span>, 1, <span class="string">'tf'</span>, 4, <span class="string">'contrast'</span>, 0.7, <span class="string">'size'</span>, 3, <span class="string">'angle'</span>, 45,<span class="keyword">...</span>
	<span class="string">'xPosition'</span>, 0, <span class="string">'yPosition'</span>, -10, <span class="string">'mask'</span>, true, <span class="string">'sigma'</span>, 30);

myStims{4}=gratingStimulus(<span class="string">'sf'</span>, 3, <span class="string">'contrast'</span>, 0.75, <span class="string">'tf'</span>, 1, <span class="string">'size'</span>, 3, <span class="string">'xPosition'</span>, -3,<span class="keyword">...</span>
	<span class="string">'yPosition'</span>, -5);

myStims{5}=gratingStimulus(<span class="string">'type'</span>, <span class="string">'square'</span>, <span class="string">'sf'</span>, 1, <span class="string">'contrast'</span>, 1, <span class="string">'colour'</span>, [0.5 0.5 0.5], <span class="string">'tf'</span>, 0,<span class="keyword">...</span>
	<span class="string">'size'</span>, 3, <span class="string">'xPosition'</span>, 3, <span class="string">'yPosition'</span>, 0, <span class="string">'sigma'</span>,30, <span class="string">'useAlpha'</span>, true);
</pre><p>This is a colour grating where two independant colours can be modulated relative to a base colour, in this case this is a red/green grating modulating from 0.5 background grey.</p><pre class="codeinput">myStims{6}=colourGratingStimulus(<span class="string">'colour'</span>, [1 0 0 1], <span class="string">'colour2'</span>, [0 1 0 1],<span class="keyword">...</span>
	<span class="string">'baseColour'</span>, [0.5 0.5 0.5], <span class="string">'tf'</span>, 1, <span class="string">'size'</span>, 3, <span class="string">'xPosition'</span>, 0, <span class="string">'yPosition'</span>, 6);
</pre><p>coherent dot stimulus; 200 dots moving at 2deg/s with coherence set to 0.25</p><pre class="codeinput">myStims{7}=dotsStimulus(<span class="string">'density'</span>,50,<span class="string">'coherence'</span>,0.25,<span class="string">'xPosition'</span>,4,<span class="keyword">...</span>
	<span class="string">'yPosition'</span>,6,<span class="string">'dotType'</span>,3,<span class="string">'dotSize'</span>,0.1,<span class="string">'colorType'</span>,<span class="string">'randomBW'</span>,<span class="string">'mask'</span>,true);
</pre><p>A simple bar: bars can be solid in colour or have checkerboard/random texture (try setting 'type' to 'random'). This is a bar moving at 4deg/s. Notice the startPosition is -4; this means start -4 degrees "behind" X and Y position, as the stimulus is displayed for 2 seconds the bar therefore traverses 4 degrees behind then 4 degrees past the X and Y position (i.e. drift a bar over a RF location) Also note as we will change the angle of this stimulus the geometry is calculated for you automatically!</p><pre class="codeinput">myStims{8}=barStimulus(<span class="string">'type'</span>,<span class="string">'checkerboard'</span>,<span class="string">'checkSize'</span>,0.25,<span class="string">'barWidth'</span>,1,<span class="string">'barLength'</span>,4,<span class="keyword">...</span>
	<span class="string">'speed'</span>,4,<span class="string">'xPosition'</span>,0,<span class="string">'yPosition'</span>,0,<span class="string">'startPosition'</span>,-4,<span class="string">'phaseReverseTime'</span>,0.5);
</pre><p>an edge-smoothed spot; spots can also flash if needed</p><pre class="codeinput">myStims{9}=discStimulus(<span class="string">'type'</span>,<span class="string">'flash'</span>,<span class="string">'speed'</span>,2,<span class="string">'xPosition'</span>,4,<span class="keyword">...</span>
	<span class="string">'yPosition'</span>,4,<span class="string">'colour'</span>,[1 1 0],<span class="string">'size'</span>,2,<span class="string">'flashTime'</span>,[0.2 0.15]);
</pre><p>a texture stimulus, by default this loads a picture from the opticka stimulus directory; you can rotate it, scale it etc and drift it across screen as in this case. Size is in degrees, scaling the whole picture</p><pre class="codeinput">myStims{10}=textureStimulus(<span class="string">'speed'</span>,2,<span class="string">'xPosition'</span>,-10,<span class="string">'yPosition'</span>,10,<span class="string">'size'</span>,4);
</pre><p>a movie stimulus, by default this loads a movie from the opticka stimulus directory; you can rotate it, scale it etc and drift it across screen as in this case. Size is in degrees, scaling the whole movie</p><pre class="codeinput">myStims{11}=movieStimulus(<span class="string">'speed'</span>,1,<span class="string">'xPosition'</span>,-5,<span class="string">'yPosition'</span>,-10,<span class="keyword">...</span>
	<span class="string">'mask'</span>,[0 0 0],<span class="string">'size'</span>,3);
</pre><h2 id="11">Task Initialisation</h2><p>The stimulusSequence class defines a stimulus sequence (task) which is composed of randomised stimulus parameter changes (called variables) repeated over a set of blocks. A trial is an individual stimulus presentation. This example has three different variables changing over 3*2*2 values (12 unique trials) which is then repeated over 2 blocks for 24 trials in total.</p><p>NOTE: for more complex behavioural tasks, Opticka uses a finite state machine to generate flexible experimental protocols, see stateMachine() for more details.</p><pre class="codeinput">myTask = stimulusSequence; <span class="comment">%new stimulusSequence object instance</span>
myTask.nBlocks = 2; <span class="comment">%number of blocks</span>
myTask.trialTime = 2; <span class="comment">%time of stimulus display: 2 seconds</span>
myTask.isTime = 0.25; <span class="comment">%inter trial time: 0.25 seconds</span>
myTask.ibTime=0.5; <span class="comment">%inter block time: 1 second</span>
myTask.realTime = true; <span class="comment">%we use real time for switching trials, false uses a tick timer updated every flip</span>
</pre><h2 id="12">Variable 1</h2><p>Our first variable is angle, applied to stimulus 1 3 7 and 10, randomly selected from values of 0 45 and 90 degrees</p><pre class="codeinput">myTask.nVar(1).name = <span class="string">'angle'</span>;
myTask.nVar(1).stimulus = [1 3 8 10];
myTask.nVar(1).values = [0 45 90];
<span class="comment">% the next two parameters allow us to link a stimulus with</span>
<span class="comment">% an offset; for example you could set stimulus 1 to values [1 2 3]</span>
<span class="comment">% and if offsetvalue was 2 and offsetstimulus was 2 then the second</span>
<span class="comment">% stimulus would change through [3 4 5];</span>
myTask.nVar(1).offsetstimulus = [6 11];
myTask.nVar(1).offsetvalue = [90];
</pre><h2 id="13">Variable 2</h2><p>Our second variable is contrast, applied to stimulus 2 and 3, randomly selected from values of 0.025 and 0.1</p><pre class="codeinput">myTask.nVar(2).name = <span class="string">'contrast'</span>;
myTask.nVar(2).stimulus = [2 3 5];
myTask.nVar(2).values = [0.15 0.55];
</pre><h2 id="14">Variable 3</h2><p>Our third variable is X position, applied to stimulus 2 and 8, randomly selected from values of -3 and 3 degrees from visual center of screen</p><pre class="codeinput">myTask.nVar(3).name = <span class="string">'xPosition'</span>;
myTask.nVar(3).stimulus = [2 7];
myTask.nVar(3).values = [-6 6];
<span class="comment">% the next two parameters allow us to link a stimulus with</span>
<span class="comment">% an offset; for example you could set stimulus 1 to values [1 2 3]</span>
<span class="comment">% and if offsetvalue was 2 and offsetstimulus was 2 then the second</span>
<span class="comment">% stimulus would change through [3 4 5]; in this case we offset stimulus 10</span>
<span class="comment">% to +1 the values above i.e. [-5 7]</span>
myTask.nVar(3).offsetstimulus = [10];
myTask.nVar(3).offsetvalue = [2];
</pre><h2 id="15">Randomisation</h2><p>We call the method to randomise the trials in a block structure</p><pre class="codeinput">randomiseStimuli(myTask);
</pre><h2 id="16">Visual Trial List</h2><p>Lets print out a table of the stimulus properties for every trial</p><pre class="codeinput">showLog(myTask);
</pre><img vspace="5" hspace="5" src="optickatest_01.png" alt=""> <h2 id="17">Setup screenManager Object</h2><p>we initialise the object with parameter options to open the PTB screen with. Note distance and pixels per cm define the resultant geometry &gt; pixel mappings. You can set several screen parameters, windowing, blending etc. hideFlash uses a trick from Mario to set the CLqUT to the task background colour so you don't see the black flash on PTB screen initialisation.</p><pre class="codeinput">myScreen = screenManager(<span class="string">'distance'</span>, 57.3,<span class="keyword">...</span><span class="comment"> %display distance from observer</span>
	<span class="string">'pixelsPerCm'</span>, 32,<span class="keyword">...</span><span class="comment"> %calibration value for screen size/pixel density, see calibrateSize()</span>
	<span class="string">'backgroundColour'</span>, [0.5 0.5 0.5],<span class="keyword">...</span><span class="comment"> %initial background colour</span>
	<span class="string">'blend'</span>, true,<span class="keyword">...</span><span class="comment"> %enable OpenGL blending, you can also set blend modes when needed</span>
	<span class="string">'srcMode'</span>, <span class="string">'GL_ONE'</span>,<span class="keyword">...</span><span class="comment"> %src blend mode</span>
	<span class="string">'dstMode'</span>, <span class="string">'GL_ZERO'</span>,<span class="keyword">...</span><span class="comment"> %dst blend mode</span>
	<span class="string">'windowed'</span>, [0 0 1000 1000],<span class="keyword">...</span><span class="comment"> %set to a widthxheight for debugging i.e. [800 600]; set to empty for fullscreen</span>
	<span class="string">'antiAlias'</span>, 0,<span class="keyword">...</span><span class="comment"> %can be set to 4 or 8x oversampling with no dropped frames on macOS ATI 5870</span>
	<span class="string">'bitDepth'</span>, <span class="string">'FloatingPoint32bitIfPossible'</span>,<span class="keyword">...</span><span class="comment"> %8bit, FloatingPoint16bit FloatingPoint32bit etc.</span>
	<span class="string">'displayPPRefresh'</span>, 100); <span class="comment">%set refresh to 100Hz only if Dispay++ attached</span>
</pre><h2 id="18">Setup runExperiment Object</h2><p>We now pass our stimulus screen and sequence objects to the runExperiment class. runExperiment contains the run() method that actually runs the task.</p><pre class="codeinput">rExp = runExperiment(<span class="string">'stimuli'</span>, myStims,<span class="keyword">...</span><span class="comment"> %stimulus objects</span>
	<span class="string">'task'</span>, myTask,<span class="keyword">...</span><span class="comment"> %task design object</span>
	<span class="string">'screen'</span>, myScreen,<span class="keyword">...</span><span class="comment"> %screen manager object</span>
	<span class="string">'debug'</span>, false,<span class="keyword">...</span><span class="comment"> %disable debug mode</span>
	<span class="string">'verbose'</span>, false); <span class="comment">%minimal verbosity</span>
</pre><p>run our experiment, to exit early, press [q] during the interstimulus period.</p><pre class="codeinput">run(rExp);
</pre><pre class="codeoutput">
---&gt; screenManager: Skipping Sync Tests etc. - ONLY FOR DEVELOPMENT!
---&gt; screenManager: Probing for a Display++...BitsPlusPlus: Could not find a Bits# config file under [/Users/ian/Library/Preferences/Psychtoolbox/BitsSharpConfig.txt]. Assuming a Bits+ device instead of a Bits# is connected.
BitsPlusPlus: Please create a config file under this name if you have a Bits# and want to use it as Bits# instead of as a Bits+.
BitsPlusPlus: The most simple way is to create an empty file. A more robust way is to store the name of the Bits# serial port
BitsPlusPlus: in the first line of the text file, e.g., COM5 [Windows], or /dev/ttyACM0 [Linux] or similar.
	NO Display++...

---&gt; screenManager: Bit Depth mode set to: FloatingPoint32BitIfPossible
PTB-WARNING: ==================================================================================================================
PTB-WARNING: DESKTOP COMPOSITOR IS ACTIVE! ALL FLIP STIMULUS ONSET TIMESTAMPS WILL BE VERY LIKELY UNRELIABLE AND LESS ACCURATE!
PTB-WARNING: STIMULUS ONSET TIMING WILL BE UNRELIABLE AS WELL, AND GRAPHICS PERFORMANCE MAY BE REDUCED!
PTB-WARNING: DO NOT USE THIS MODE FOR RUNNING REAL EXPERIMENT SESSIONS WITH ANY REQUIREMENTS FOR ACCURATE TIMING!
PTB-WARNING: ==================================================================================================================
PTB-INFO: All display tests and calibrations disabled. Assuming a refresh interval of 60.000000 Hz. Timing will be inaccurate!

---&gt; screenManager: Previous OpenGL blending: GL_ONE | GL_ZERO
---&gt; screenManager: OpenGL blending now: GL_ONE | GL_ZERO
Compiling all shaders matching BasicSineGratingShader * into a GLSL program.
Building a fragment shader:Reading shader from file /Users/ian/Code/Psychtoolbox-3/Psychtoolbox/PsychOpenGL/PsychGLSLShaders/BasicSineGratingShader.frag.txt ...
Building a vertex shader:Reading shader from file /Users/ian/Code/Psychtoolbox-3/Psychtoolbox/PsychOpenGL/PsychGLSLShaders/BasicSineGratingShader.vert.txt ...
Compiling all shaders matching NonSymetricGaborShader * into a GLSL program.
Building a fragment shader:Reading shader from file /Users/ian/Code/Psychtoolbox-3/Psychtoolbox/PsychOpenGL/PsychGLSLShaders/NonSymetricGaborShader.frag.txt ...
Building a vertex shader:Reading shader from file /Users/ian/Code/Psychtoolbox-3/Psychtoolbox/PsychOpenGL/PsychGLSLShaders/NonSymetricGaborShader.vert.txt ...
Compiling all shaders matching SineGratingSmoothedApertureShader * into a GLSL program.
Building a fragment shader:Reading shader from file /Users/ian/Code/Psychtoolbox-3/Psychtoolbox/PsychOpenGL/PsychGLSLShaders/SineGratingSmoothedApertureShader.frag.txt ...
Building a vertex shader:Reading shader from file /Users/ian/Code/Psychtoolbox-3/Psychtoolbox/PsychOpenGL/PsychGLSLShaders/SineGratingSmoothedApertureShader.vert.txt ...
Building a vertex shader:Reading shader from file /Users/ian/Code/Psychtoolbox-3/Psychtoolbox/PsychOpenGL/PsychGLSLShaders/BasicSineGratingShader.vert.txt ...
Building a fragment shader:Reading shader from file /Users/ian/Code/Psychtoolbox-3/Psychtoolbox/PsychOpenGL/PsychGLSLShaders/ApertureSineGratingShader.frag.txt ...
Compiling all shaders matching SquareWaveApertureShader * into a GLSL program.
Building a fragment shader:Reading shader from file /Users/ian/Code/Psychtoolbox-3/Psychtoolbox/PsychOpenGL/PsychGLSLShaders/SquareWaveApertureShader.frag.txt ...
Building a vertex shader:Reading shader from file /Users/ian/Code/Psychtoolbox-3/Psychtoolbox/PsychOpenGL/PsychGLSLShaders/SquareWaveApertureShader.vert.txt ...
Building a vertex shader:Reading shader from file /Users/ian/Code/opticka/stimuli/colorgrating.vert ...
Building a fragment shader:Reading shader from file /Users/ian/Code/opticka/stimuli/colorgrating.frag ...
Compiling all shaders matching SmoothedDiscShader * into a GLSL program.
Building a fragment shader:Reading shader from file /Users/ian/Code/Psychtoolbox-3/Psychtoolbox/PsychOpenGL/PsychGLSLShaders/SmoothedDiscShader.frag.txt ...
Building a vertex shader:Reading shader from file /Users/ian/Code/Psychtoolbox-3/Psychtoolbox/PsychOpenGL/PsychGLSLShaders/SmoothedDiscShader.vert.txt ...
Compiling all shaders matching SmoothedDiscShader * into a GLSL program.
Building a fragment shader:Reading shader from file /Users/ian/Code/Psychtoolbox-3/Psychtoolbox/PsychOpenGL/PsychGLSLShaders/SmoothedDiscShader.frag.txt ...
Building a vertex shader:Reading shader from file /Users/ian/Code/Psychtoolbox-3/Psychtoolbox/PsychOpenGL/PsychGLSLShaders/SmoothedDiscShader.vert.txt ...
---&gt; textureStimulus#23E79FD67: Load: /Users/ian/Code/opticka/stimuli/Bosch.jpeg | loadImage

---&gt;&gt;&gt; movieStimulus: /Users/ian/Code/opticka/stimuli/monkey-dance.mp4
	1.04 seconds duration, 25.000000 fps, w x h = 350 x 350, in 197ms
	Blocking: 0 | Loop: 1 | Preloadsecs: -1 | Pixelformat:  | Flags: 
Compiling all shaders matching /Users/ian/Code/Psychtoolbox-3/Psychtoolbox/PsychOpenGL/PsychGLSLShaders/ColorMaskedTextureBlitShader.frag.txt * into a GLSL program.
Building a fragment shader:Reading shader from file /Users/ian/Code/Psychtoolbox-3/Psychtoolbox/PsychOpenGL/PsychGLSLShaders/ColorMaskedTextureBlitShader.frag.txt ...
---&gt; ioManager#23E82D96D: Constructor parsing input argument | name
---&gt; ioManager#23E82E31C: Constructor parsing input argument | name
---&gt; stimulusSequence.initialise: Randomised and Initialised!

===&gt;&gt;&gt; Warming up the GPU and I/O systems... &lt;&lt;&lt;===
START @B: 1 | R: 1 [1/24] | isBlank: 1 | Time: 0.000 (0) | V: 12 | / angle: 90.00 / contrast: 0.55 / xPosition: 6.00

@B: 1 | R: 1 [1/24] | isBlank: 1 | Time: 0.000 (2) | V: 12 | / angle: 90.00 / contrast: 0.55 / xPosition: 6.00

IS TIME: 1
@B: 1 | R: 2 [2/24] | isBlank: 1 | Time: 2.273 (138) | V: 4 | / angle: 0.00 / contrast: 0.55 / xPosition: 6.00

IS TIME: 1
@B: 1 | R: 3 [3/24] | isBlank: 1 | Time: 5.274 (318) | V: 11 | / angle: 90.00 / contrast: 0.55 / xPosition: -6.00

IS TIME: 1
@B: 1 | R: 4 [4/24] | isBlank: 1 | Time: 8.274 (498) | V: 6 | / angle: 45.00 / contrast: 0.15 / xPosition: 6.00

IS TIME: 1
@B: 1 | R: 5 [5/24] | isBlank: 1 | Time: 11.275 (678) | V: 3 | / angle: 0.00 / contrast: 0.55 / xPosition: -6.00

IS TIME: 1
@B: 1 | R: 6 [6/24] | isBlank: 1 | Time: 14.275 (858) | V: 8 | / angle: 45.00 / contrast: 0.55 / xPosition: 6.00


---&gt; screenManager: RESET GAMMA TABLES
---&gt; Number of dropped movie frames: 0

---&gt; screenManager: RESET GAMMA TABLES
---&gt; screenManager: RESET OPENGL BLEND MODE to GL_ONE &amp; GL_ZERO


WARNING: This session of your experiment was run by you with the setting Screen('Preference', 'SkipSyncTests', 2).
WARNING: This means that some internal self-tests and calibrations were skipped. Your stimulus presentation timing
WARNING: may have been wrong. This is fine for development and debugging of your experiment, but for running the real
WARNING: study, please make sure to set Screen('Preference', 'SkipSyncTests', 0) for maximum accuracy and reliability.
</pre><p>Plot a timing log of every frame against the stimulus on/off times:</p><pre class="codeinput">getRunLog(rExp);
</pre><img vspace="5" hspace="5" src="optickatest_02.png" alt=""> <p>The image above is a graphical timing plot of every frame and whether any frames were dropped during stimulus presentation. This will not consider dropped frames during the GPU warming or inter trial time as dropped as the display is blank and we are using absolute time values for our trial transitions. Opticka actually resets and updates the stimulus objects on the second and subsequent frames of the inter trial blank, this forces any computation of stimulus parameter to when it doesn't matter; but note for complex stimuli a frame or two may be dropped during the blank and so ensure you set the inter trial time &gt; than the dropped frames!</p><p>You don't need to use opticka's stimuli using runExperiment(), you can use them in your own simple experiments, lets have a quick look here.</p><pre class="codeinput">WaitSecs(<span class="string">'YieldSecs'</span>,2);
myMovie = myStims{11}; <span class="comment">% the movie stimulus from above</span>
open(myScreen); <span class="comment">%open a screen</span>
setup(myMovie, myScreen); <span class="comment">%setup the stimulus with the screen configuration</span>
<span class="keyword">for</span> i = 1:myScreen.screenVals.fps
	draw(myMovie);
	finishDrawing(myScreen);
	animate(myMovie);
	flip(myScreen);
<span class="keyword">end</span>
reset(myMovie);
close(myScreen);
</pre><pre class="codeoutput">
---&gt; screenManager: Skipping Sync Tests etc. - ONLY FOR DEVELOPMENT!
---&gt; screenManager: Probing for a Display++...BitsPlusPlus: Could not find a Bits# config file under [/Users/ian/Library/Preferences/Psychtoolbox/BitsSharpConfig.txt]. Assuming a Bits+ device instead of a Bits# is connected.
BitsPlusPlus: Please create a config file under this name if you have a Bits# and want to use it as Bits# instead of as a Bits+.
BitsPlusPlus: The most simple way is to create an empty file. A more robust way is to store the name of the Bits# serial port
BitsPlusPlus: in the first line of the text file, e.g., COM5 [Windows], or /dev/ttyACM0 [Linux] or similar.
	NO Display++...

---&gt; screenManager: Bit Depth mode set to: FloatingPoint32BitIfPossible
PTB-WARNING: ==================================================================================================================
PTB-WARNING: DESKTOP COMPOSITOR IS ACTIVE! ALL FLIP STIMULUS ONSET TIMESTAMPS WILL BE VERY LIKELY UNRELIABLE AND LESS ACCURATE!
PTB-WARNING: STIMULUS ONSET TIMING WILL BE UNRELIABLE AS WELL, AND GRAPHICS PERFORMANCE MAY BE REDUCED!
PTB-WARNING: DO NOT USE THIS MODE FOR RUNNING REAL EXPERIMENT SESSIONS WITH ANY REQUIREMENTS FOR ACCURATE TIMING!
PTB-WARNING: ==================================================================================================================
PTB-INFO: All display tests and calibrations disabled. Assuming a refresh interval of 60.000000 Hz. Timing will be inaccurate!

---&gt; screenManager: Previous OpenGL blending: GL_ONE | GL_ZERO
---&gt; screenManager: OpenGL blending now: GL_ONE | GL_ZERO

---&gt;&gt;&gt; movieStimulus: /Users/ian/Code/opticka/stimuli/monkey-dance.mp4
	1.04 seconds duration, 25.000000 fps, w x h = 350 x 350, in 30ms
	Blocking: 0 | Loop: 1 | Preloadsecs: -1 | Pixelformat:  | Flags: 
Compiling all shaders matching /Users/ian/Code/Psychtoolbox-3/Psychtoolbox/PsychOpenGL/PsychGLSLShaders/ColorMaskedTextureBlitShader.frag.txt * into a GLSL program.
Building a fragment shader:Reading shader from file /Users/ian/Code/Psychtoolbox-3/Psychtoolbox/PsychOpenGL/PsychGLSLShaders/ColorMaskedTextureBlitShader.frag.txt ...
---&gt; Number of dropped movie frames: 0

---&gt; screenManager: RESET GAMMA TABLES
---&gt; screenManager: RESET OPENGL BLEND MODE to GL_ONE &amp; GL_ZERO


WARNING: This session of your experiment was run by you with the setting Screen('Preference', 'SkipSyncTests', 2).
WARNING: This means that some internal self-tests and calibrations were skipped. Your stimulus presentation timing
WARNING: may have been wrong. This is fine for development and debugging of your experiment, but for running the real
WARNING: study, please make sure to set Screen('Preference', 'SkipSyncTests', 0) for maximum accuracy and reliability.
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2019b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Demonstration of a command-driven setup of an Opticka Experiment.
% Opticka is an object oriented framework/GUI for the
% Psychophysics toolbox, allowing randomised interleaved presentation of 
% parameter varying stimuli specified in experimenter-relevant values. 
% It is designed to work on OS X, Windows (currently no digital I/O) 
% or Linux, and can interface via strobed words (using a cheap and 
% very reliable LabJack) and ethernet with external harware for 
% recording neurophysiological data.
% In this example, Stimulus objects (myStims class cell array), 
% stimulus sequence variables (myTask object), and 
% screenManager (myScreen object) are passed to the
% runExperiment object for final display. Opticka also has a UI (type
% opticka in the command window), which is a visual manager of the objects
% introduced here. The UI also controls other functions such as
% calibration, protocol loading/saving and communication with
% neurophysiological equipment via LabJack and ethernet. There is also an
% independent receptive field mapper (rfMapper) that uses mouse control to probe
% receptive fields and generate drawn hand maps.
%
% The source of this file can be found at:
% <https://github.com/iandol/opticka/blob/master/optickatest.m>

%% Initial clear up of previous runs
% Make sure we start in a clean environment, not essential
clear myStims myTask myScreen rExp
sca %PTB screen clear all

%% Stimulus Initialisation
% These set up the 10 different stimuli. Please note that values are in
% degrees, cycles/deg, deg/s etc. Colour is repestend using floating point
% values from 0 - 1 and all objects accept an opacity (alpha) value.
% Each stimulus is a class object with a series of properties ('sf',
% 'colour' etc.) that you can set up by simply passing property name : value pairs 
% into the stimulus class. You can also pass these in as a structure if you prefer. 
% If you do not pass any properties, default values will be used without problems.

%%
% First we create a stimulus manager object that collects and handles groups of
% stimuli as if they were a single 'thing', so for example when you use the
% draw method on a metaStimulus, it tells each of its child stimuli to draw in order
myStims = metaStimulus();

%%
% Stimului are made using stimulus classes. Each class inherits from
% baseStimulus, which has 5 abstract classes ALL stimuli must implement:
% [1] SETUP(screenManager) - takes a screenManager and sets up the
% stimulus properties ready for display.
% [2] DRAW() - draws the stimulus
% [3] ANIMATE() - for each stimulus class, animate takes speed, tf etc. and
% updates the position onscreen for the next flip.
% [4] UPDATE() - if any parameters have changed (size, position, colour
% etc.), then update ensures all properties are properly updated.
% [5] RESET() - returns the object back to its pre-setup state.
%
%The first five stimuli are gratings / gabors of varying kinds.
myStims{1}=gratingStimulus('sf', 1, 'tf', 0, 'phase', 90, 'contrast', 0.7, 'size', 2, 'angle', -45,...
	'mask', false);

myStims{2}=gaborStimulus('sf', 1, 'contrast', 0.75, 'tf', 3, 'size', 3, 'angle', -70,...
	'aspectRatio', 0.5, 'xPosition', 5, 'yPosition', -5);

myStims{3}=gratingStimulus('sf', 1, 'tf', 4, 'contrast', 0.7, 'size', 3, 'angle', 45,...
	'xPosition', 0, 'yPosition', -10, 'mask', true, 'sigma', 30);

myStims{4}=gratingStimulus('sf', 3, 'contrast', 0.75, 'tf', 1, 'size', 3, 'xPosition', -3,...
	'yPosition', -5);

myStims{5}=gratingStimulus('type', 'square', 'sf', 1, 'contrast', 1, 'colour', [0.5 0.5 0.5], 'tf', 0,...
	'size', 3, 'xPosition', 3, 'yPosition', 0, 'sigma',30, 'useAlpha', true);

%%
% This is a colour grating where two independant colours can be modulated
% relative to a base colour, in this case this is a red/green grating
% modulating from 0.5 background grey.
myStims{6}=colourGratingStimulus('colour', [1 0 0 1], 'colour2', [0 1 0 1],...
	'baseColour', [0.5 0.5 0.5], 'tf', 1, 'size', 3, 'xPosition', 0, 'yPosition', 6);

%%
% coherent dot stimulus; 200 dots moving at 2deg/s with coherence set to 0.25
myStims{7}=dotsStimulus('density',50,'coherence',0.25,'xPosition',4,...
	'yPosition',6,'dotType',3,'dotSize',0.1,'colorType','randomBW','mask',true);

%%
% A simple bar: bars can be solid in colour or have checkerboard/random texture 
% (try setting 'type' to 'random'). This is a bar moving at 4deg/s. 
% Notice the startPosition is -4; this means start -4 degrees "behind" X and Y position, as
% the stimulus is displayed for 2 seconds the bar therefore traverses
% 4 degrees behind then 4 degrees past the X and Y position (i.e. drift a bar over a RF location)
% Also note as we will change the angle of this stimulus the geometry is calculated for you
% automatically!
myStims{8}=barStimulus('type','checkerboard','checkSize',0.25,'barWidth',1,'barLength',4,...
	'speed',4,'xPosition',0,'yPosition',0,'startPosition',-4,'phaseReverseTime',0.5);

%%
% an edge-smoothed spot; spots can also flash if needed
myStims{9}=discStimulus('type','flash','speed',2,'xPosition',4,...
	'yPosition',4,'colour',[1 1 0],'size',2,'flashTime',[0.2 0.15]);

%%
% a texture stimulus, by default this loads a picture from the opticka
% stimulus directory; you can rotate it, scale it etc and drift it across screen as
% in this case. Size is in degrees, scaling the whole picture
myStims{10}=textureStimulus('speed',2,'xPosition',-10,'yPosition',10,'size',4);

%%
% a movie stimulus, by default this loads a movie from the opticka
% stimulus directory; you can rotate it, scale it etc and drift it across screen as
% in this case. Size is in degrees, scaling the whole movie
myStims{11}=movieStimulus('speed',1,'xPosition',-5,'yPosition',-10,...
	'mask',[0 0 0],'size',3);

%% Task Initialisation
% The stimulusSequence class defines a stimulus sequence (task) which is composed
% of randomised stimulus parameter changes (called variables) repeated over
% a set of blocks. A trial is an individual stimulus presentation. This
% example has three different variables changing over 3*2*2 values (12 unique trials) which is
% then repeated over 2 blocks for 24 trials in total.
%
% NOTE: for more complex behavioural tasks, Opticka uses a finite state machine to generate flexible
% experimental protocols, see stateMachine() for more details.
myTask = stimulusSequence; %new stimulusSequence object instance
myTask.nBlocks = 2; %number of blocks
myTask.trialTime = 2; %time of stimulus display: 2 seconds
myTask.isTime = 0.25; %inter trial time: 0.25 seconds
myTask.ibTime=0.5; %inter block time: 1 second
myTask.realTime = true; %we use real time for switching trials, false uses a tick timer updated every flip

%% Variable 1
% Our first variable is angle, applied to stimulus 1 3 7 and 10, randomly
% selected from values of 0 45 and 90 degrees
myTask.nVar(1).name = 'angle';
myTask.nVar(1).stimulus = [1 3 8 10];
myTask.nVar(1).values = [0 45 90];
% the next two parameters allow us to link a stimulus with
% an offset; for example you could set stimulus 1 to values [1 2 3]
% and if offsetvalue was 2 and offsetstimulus was 2 then the second
% stimulus would change through [3 4 5]; 
myTask.nVar(1).offsetstimulus = [6 11];
myTask.nVar(1).offsetvalue = [90];

%% Variable 2
% Our second variable is contrast, applied to stimulus 2 and 3, randomly
% selected from values of 0.025 and 0.1
myTask.nVar(2).name = 'contrast';
myTask.nVar(2).stimulus = [2 3 5];
myTask.nVar(2).values = [0.15 0.55];

%% Variable 3
% Our third variable is X position, applied to stimulus 2 and 8, randomly
% selected from values of -3 and 3 degrees from visual center of screen
myTask.nVar(3).name = 'xPosition';
myTask.nVar(3).stimulus = [2 7];
myTask.nVar(3).values = [-6 6];
% the next two parameters allow us to link a stimulus with
% an offset; for example you could set stimulus 1 to values [1 2 3]
% and if offsetvalue was 2 and offsetstimulus was 2 then the second
% stimulus would change through [3 4 5]; in this case we offset stimulus 10
% to +1 the values above i.e. [-5 7]
myTask.nVar(3).offsetstimulus = [10];
myTask.nVar(3).offsetvalue = [2];

%% Randomisation
% We call the method to randomise the trials in a block structure
randomiseStimuli(myTask);

%% Visual Trial List
% Lets print out a table of the stimulus properties for every trial
showLog(myTask);

%% Setup screenManager Object
% we initialise the object with parameter options to open the PTB screen
% with. Note distance and pixels per cm define the resultant geometry >
% pixel mappings. You can set several screen parameters, windowing,
% blending etc. hideFlash uses a trick from Mario to set the CLqUT to the
% task background colour so you don't see the black flash on PTB screen
% initialisation.
myScreen = screenManager('distance', 57.3,... %display distance from observer
	'pixelsPerCm', 32,... %calibration value for screen size/pixel density, see calibrateSize()
	'backgroundColour', [0.5 0.5 0.5],... %initial background colour
	'blend', true,... %enable OpenGL blending, you can also set blend modes when needed
	'srcMode', 'GL_ONE',... %src blend mode
	'dstMode', 'GL_ZERO',... %dst blend mode
	'windowed', [0 0 1000 1000],... %set to a widthxheight for debugging i.e. [800 600]; set to empty for fullscreen
	'antiAlias', 0,... %can be set to 4 or 8x oversampling with no dropped frames on macOS ATI 5870
	'bitDepth', 'FloatingPoint32bitIfPossible',... %8bit, FloatingPoint16bit FloatingPoint32bit etc.
	'displayPPRefresh', 100); %set refresh to 100Hz only if Dispay++ attached

%% Setup runExperiment Object
% We now pass our stimulus screen and sequence objects to the
% runExperiment class. runExperiment contains the run() method that actually
% runs the task.
rExp = runExperiment('stimuli', myStims,... %stimulus objects
	'task', myTask,... %task design object
	'screen', myScreen,... %screen manager object
	'debug', false,... %disable debug mode
	'verbose', false); %minimal verbosity

%%
% run our experiment, to exit early, press [q] during the interstimulus period.
run(rExp);

%%
% Plot a timing log of every frame against the stimulus on/off times:
getRunLog(rExp);

%%
% The image above is a graphical timing plot of every frame and whether any frames
% were dropped during stimulus presentation. This will not consider
% dropped frames during the GPU warming or inter trial time as dropped as the display is
% blank and we are using absolute time values for our trial transitions.
% Opticka actually resets and updates the stimulus objects on the second
% and subsequent frames of the inter trial blank, this forces any computation of
% stimulus parameter to when it doesn't matter; but note
% for complex stimuli a frame or two may be dropped during the blank and so
% ensure you set the inter trial time > than the dropped frames!

%%
% You don't need to use opticka's stimuli using runExperiment(), you can
% use them in your own simple experiments, lets have a quick look here.
WaitSecs('YieldSecs',2);
myMovie = myStims{11}; % the movie stimulus from above
open(myScreen); %open a screen
setup(myMovie, myScreen); %setup the stimulus with the screen configuration
for i = 1:myScreen.screenVals.fps
	draw(myMovie);
	finishDrawing(myScreen);
	animate(myMovie);
	flip(myScreen);
end
reset(myMovie);
close(myScreen);

##### SOURCE END #####
--></body></html>