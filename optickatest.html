
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Demonstration of a command-driven setup of an Opticka Experiment.</title><meta name="generator" content="MATLAB 9.4"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2018-09-01"><meta name="DC.source" content="optickatest.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Demonstration of a command-driven setup of an Opticka Experiment.</h1><!--introduction--><p>Opticka is an object oriented framework/GUI for the Psychophysics toolbox, allowing randomised interleaved presentation of parameter varying stimuli specified in experimenter-relevant values. It is designed to work on OS X, Windows (currently no digital I/O) or Linux, and can interface via strobed words (using a cheap and very reliable LabJack) and ethernet with external harware for recording neurophysiological data. In this example, Stimulus objects (myStims class cell array), stimulus sequence variables (myTask object), and screenManager (myScreen object) are passed to the runExperiment object for final display. Opticka also has a UI (type opticka in the command window), which is a visual manager of the objects introduced here. The UI also controls other functions such as calibration, protocol loading/saving and communication with neurophysiological equipment via LabJack and ethernet. There is also an independent receptive field mapper (rfMapper) that uses mouse control to probe receptive fields and generate drawn hand maps.</p><p>The source of this file can be found at: <a href="https://github.com/iandol/opticka/blob/master/optickatest.m">https://github.com/iandol/opticka/blob/master/optickatest.m</a></p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Initial clear up of previous runs</a></li><li><a href="#2">Stimulus Initialisation</a></li><li><a href="#9">Task Initialisation</a></li><li><a href="#10">Variable 1</a></li><li><a href="#11">Variable 2</a></li><li><a href="#12">Variable 3</a></li><li><a href="#13">Randomisation</a></li><li><a href="#14">Visual Trial List</a></li><li><a href="#15">Setup screenManager Object</a></li><li><a href="#16">Setup runExperiment Object</a></li></ul></div><h2 id="1">Initial clear up of previous runs</h2><p>Make sure we start in a clean environment, not essential</p><pre class="codeinput">clear <span class="string">myStims</span> <span class="string">myTask</span> <span class="string">myScreen</span> <span class="string">rExp</span>
sca <span class="comment">%PTB screen clear all</span>
</pre><h2 id="2">Stimulus Initialisation</h2><p>These set up the 10 different stimuli. Please note that values are in degrees, cycles/deg, deg/s etc. Colour is repestend using floating point values from 0 - 1 and all objects accept an opacity (alpha) value. Each stimulus is a class object with a series of properties ('sf', 'colour' etc.) that you can set up by simply passing property name : value pairs into the stimulus class. You can also pass these in as a structure if you prefer. If you do not pass any properties, default values will be used without problems.</p><p>First we create a stimulus manager that collects and handles groups of stimuli as if they were a single 'thing', so for example when you use the draw method on a stimulus manager, it tells each of its child stimuli to draw in turn</p><pre class="codeinput">myStims = metaStimulus();
</pre><p>The first six stimuli are gratings / gabors of varying kinds.</p><pre class="codeinput">myStims{1}=gratingStimulus(<span class="string">'sf'</span>,1,<span class="string">'contrast'</span>,0.5,<span class="string">'size'</span>,1,<span class="string">'tf'</span>,0,<span class="string">'angle'</span>,30,<span class="keyword">...</span>
	<span class="string">'gabor'</span>, 0, <span class="string">'mask'</span>, 1);

myStims{2}=gratingStimulus(<span class="string">'sf'</span>,3,<span class="string">'contrast'</span>,0.5,<span class="string">'tf'</span>,1,<span class="string">'size'</span>,3,<span class="string">'xPosition'</span>,-3,<span class="keyword">...</span>
	<span class="string">'yPosition'</span>,-4,<span class="string">'gabor'</span>,1,<span class="string">'mask'</span>,0);

myStims{3}=gratingStimulus(<span class="string">'sf'</span>,1,<span class="string">'contrast'</span>,0.5,<span class="string">'size'</span>,3,<span class="string">'angle'</span>,45,<span class="string">'xPosition'</span>,-2,<span class="keyword">...</span>
	<span class="string">'yPosition'</span>,2,<span class="string">'gabor'</span>,0,<span class="string">'mask'</span>,1,<span class="string">'sigma'</span>,15,<span class="string">'speed'</span>,2);

myStims{4}=gratingStimulus(<span class="string">'sf'</span>,1,<span class="string">'contrast'</span>,0.5,<span class="string">'tf'</span>,0,<span class="string">'size'</span>,2,<span class="string">'xPosition'</span>,-3,<span class="keyword">...</span>
	<span class="string">'yPosition'</span>,-3,<span class="string">'gabor'</span>,0,<span class="string">'mask'</span>,1,<span class="string">'speed'</span>,2);

myStims{5}=gratingStimulus(<span class="string">'sf'</span>,1,<span class="string">'contrast'</span>,0.25,<span class="string">'colour'</span>,[0.6 0.3 0.3],<span class="string">'tf'</span>,0.1,<span class="keyword">...</span>
	<span class="string">'size'</span>,2,<span class="string">'xPosition'</span>,3,<span class="string">'yPosition'</span>,0,<span class="string">'gabor'</span>,0,<span class="string">'mask'</span>,0);

myStims{6}=gratingStimulus(<span class="string">'sf'</span>,1,<span class="string">'contrast'</span>,0.5,<span class="string">'colour'</span>,[0.4 0.4 0.6],<span class="string">'tf'</span>,1,<span class="keyword">...</span>
	<span class="string">'driftDirection'</span>,-1,<span class="string">'size'</span>,2,<span class="string">'xPosition'</span>,4,<span class="string">'yPosition'</span>,-4,<span class="string">'gabor'</span>,0,<span class="string">'mask'</span>,1);
</pre><p>A simple bar: bars can be solid in colour or have random texture (try setting 'type' to 'random'). This is an opaque solid yellow bar moving at 4deg/s. Notice the startPosition is -4; this means start -4 degrees "behind" start X and Y position, as the stimulus is displayed for 2 seconds the bar therefore traverses 4degrees behind then 4 degrees past the X and Y position. Also note as we will change the angle of this stimulus the geometry is calculated for you automatically!</p><pre class="codeinput">myStims{7}=barStimulus(<span class="string">'type'</span>,<span class="string">'solid'</span>,<span class="string">'barWidth'</span>,1,<span class="string">'barLength'</span>,4,<span class="string">'speed'</span>,4,<span class="string">'xPosition'</span>,0,<span class="keyword">...</span>
	<span class="string">'yPosition'</span>,0,<span class="string">'startPosition'</span>,-4,<span class="string">'colour'</span>,[.7 .7 .7]);
</pre><p>coherent dot stimulus; 200 dots moving at 1deg/s with coherence set to 0.5</p><pre class="codeinput">myStims{8}=dotsStimulus(<span class="string">'density'</span>,50,<span class="string">'speed'</span>,1,<span class="string">'coherence'</span>,0.5,<span class="string">'xPosition'</span>,4,<span class="keyword">...</span>
	<span class="string">'yPosition'</span>,6,<span class="string">'colour'</span>,[1 1 1],<span class="string">'dotType'</span>,3,<span class="string">'dotSize'</span>,0.1,<span class="string">'colorType'</span>,<span class="string">'randomBW'</span>);
</pre><p>a simple circular spot, spots can also flash if needed</p><pre class="codeinput">myStims{9}=discStimulus(<span class="string">'speed'</span>,2,<span class="string">'xPosition'</span>,4,<span class="string">'type'</span>,<span class="string">'flash'</span>,<span class="keyword">...</span>
	<span class="string">'yPosition'</span>,4,<span class="string">'colour'</span>,[1 1 1],<span class="string">'size'</span>,2,<span class="string">'flashTime'</span>,[0.2 0.2]);
</pre><p>a texture stimulus, by default this loads a picture from the opticka stimulus directory; you can rotate it, scale it etc and drift it across screen as in this case</p><pre class="codeinput">myStims{10}=textureStimulus(<span class="string">'speed'</span>,2,<span class="string">'xPosition'</span>,-6,<span class="keyword">...</span>
	<span class="string">'yPosition'</span>,6,<span class="string">'size'</span>,0.5);
</pre><h2 id="9">Task Initialisation</h2><p>The stimulusSequence class defines a stimulus sequence (task) which is composed of randomised stimulus parameter changes (called variables) repeated over a set of blocks. A trial is an individual stimulus presentation. This example has three different variables changing over 3*2*2 values (12 unique trials) which is then repeated over 2 blocks for 24 trials in total</p><pre class="codeinput">myTask = stimulusSequence; <span class="comment">%new stimulusSequence object instance</span>
myTask.nBlocks = 2; <span class="comment">%number of blocks</span>
myTask.trialTime = 2; <span class="comment">%time of stimulus display: 2 seconds</span>
myTask.isTime = 0.25; <span class="comment">%inter trial time: 0.25 seconds</span>
myTask.ibTime=0.5; <span class="comment">%inter block time: 1 second</span>
myTask.realTime = false; <span class="comment">%we use real time for switching trials, false uses a tick timer updated every flip</span>
</pre><h2 id="10">Variable 1</h2><p>Our first variable is angle, applied to stimulus 1 3 7 and 10, randomly selected from values of 0 45 and 90 degrees</p><pre class="codeinput">myTask.nVar(1).name = <span class="string">'angle'</span>;
myTask.nVar(1).stimulus = [1 3 7 10];
myTask.nVar(1).values = [0 45 90];
</pre><h2 id="11">Variable 2</h2><p>Our second variable is contrast, applied to stimulus 2 and 3, randomly selected from values of 0.025 and 0.1</p><pre class="codeinput">myTask.nVar(2).name = <span class="string">'contrast'</span>;
myTask.nVar(2).stimulus = [2 3];
myTask.nVar(2).values = [0.1 0.4];
</pre><h2 id="12">Variable 3</h2><p>Our third variable is X position, applied to stimulus 2 and 8, randomly selected from values of -3 and 3 degrees from visual center of screen</p><pre class="codeinput">myTask.nVar(3).name = <span class="string">'xPosition'</span>;
myTask.nVar(3).stimulus = [2 8];
myTask.nVar(3).values = [-3 3];
<span class="comment">% the next two parameters allow us to link a stimulus with</span>
<span class="comment">% an offset; for example you could set stimulus 1 to values [1 2 3]</span>
<span class="comment">% and if offsetvalue was 2 and offsetstimulus was 2 then the second</span>
<span class="comment">% stimulus would change through [3 4 5]; in this case we offset stimulus 10</span>
<span class="comment">% to +1 the values above i.e. [-2 4]</span>
myTask.nVar(3).offsetstimulus = [10];
myTask.nVar(3).offsetvalue = [1];
</pre><h2 id="13">Randomisation</h2><p>We call the method to randomise the trials in a block structure</p><pre class="codeinput">randomiseStimuli(myTask);
</pre><h2 id="14">Visual Trial List</h2><p>Lets print out a log of the stimulus properties for every trial</p><pre class="codeinput">showLog(myTask);
</pre><img vspace="5" hspace="5" src="optickatest_01.png" alt=""> <h2 id="15">Setup screenManager Object</h2><p>we initialise the object with parameter options to open the PTB screen with. Note distance and pixels per cm define the resultant geometry &gt; pixel mappings. You can set several screen parameters, windowing, blending etc. hideFlash uses a trick from Mario to set the CLUT to the task background colour so you don't see the black flash on PTB screen initialisation.</p><pre class="codeinput">myScreen = screenManager(<span class="string">'distance'</span>, 57.3,<span class="keyword">...</span><span class="comment"> %display distance from observer</span>
	<span class="string">'pixelsPerCm'</span>, 27.5,<span class="keyword">...</span><span class="comment"> %calibration value for screen size/pixel density, see calibrateSize()</span>
	<span class="string">'blend'</span>, true,<span class="keyword">...</span><span class="comment"> %enable OpenGL blending, you can also set blend modes when needed</span>
	<span class="string">'windowed'</span>, [ ],<span class="keyword">...</span><span class="comment"> %set to a widthxheight for debugging i.e. [800 600]; set to false for fullscreen</span>
	<span class="string">'antiAlias'</span>, 0,<span class="keyword">...</span><span class="comment"> %can be set to 4 or 8x oversampling with no dropped frames on OS X ATI 5870</span>
	<span class="string">'bitDepth'</span>, <span class="string">'FloatingPoint32bitIfPossible'</span>,<span class="keyword">...</span><span class="comment"> %try 8bit, FloatingPoint16bit FloatingPoint32bit etc.</span>
	<span class="string">'displayPPRefresh'</span>, 100, <span class="keyword">...</span><span class="comment"> %set refresh to 100Hz only if Dispay++ attached</span>
	<span class="string">'hideFlash'</span>, false); <span class="comment">%mario's gamma trick</span>
</pre><h2 id="16">Setup runExperiment Object</h2><p>We now pass our stimulus screen and sequence objects to the runExperiment class. runExperiment contains the run() method that actually runs the task.</p><pre class="codeinput">rExp = runExperiment(<span class="string">'stimuli'</span>, myStims,<span class="keyword">...</span><span class="comment"> %stimulus objects</span>
	<span class="string">'task'</span>, myTask,<span class="keyword">...</span><span class="comment"> %task design object</span>
	<span class="string">'screen'</span>, myScreen,<span class="keyword">...</span><span class="comment"> %screen manager object</span>
	<span class="string">'debug'</span>, false,<span class="keyword">...</span><span class="comment"> %setup screen to complain about sync errors etc.</span>
	<span class="string">'verbose'</span>, false); <span class="comment">%minimal verbosity</span>
</pre><p>run our experiment, to exit early, press [q] during the blank</p><pre class="codeinput">run(rExp);
</pre><pre class="codeoutput">
---&gt; screenManager: Normal Screen Preferences used.
---&gt; screenManager: Probing for a Display++...
---&gt; screenManager: Found Display++...

---&gt; screenManager: Bit Depth mode set to: FloatingPoint32BitIfPossible


PTB-INFO: This is Psychtoolbox-3 for GNU/Linux X11, under Matlab 64-Bit (Version 3.0.14 - Build date: Apr  6 2018).
PTB-INFO: Support status on this operating system release: Linux 4.15.0-33-generic Supported.
PTB-INFO: Type 'PsychtoolboxVersion' for more detailed version information.
PTB-INFO: Most parts of the Psychtoolbox distribution are licensed to you under terms of the MIT License, with
PTB-INFO: some restrictions. See file 'License.txt' in the Psychtoolbox root folder for the exact licensing conditions.

PTB-INFO: Advanced Micro Devices, Inc. [AMD/ATI] - Ellesmere [Radeon Pro WX 5100] GPU found. Trying to establish low-level access...
PTB-INFO: Connected to Advanced Micro Devices, Inc. [AMD/ATI] Ellesmere [Radeon Pro WX 5100] GPU with DCE-11.0 display engine [6 heads].
PTB-INFO: Using old-style override-redirect setup path for onscreen window creation.
PTB-INFO: Running on Mesa version 18.0.5
PTB-INFO: This combo of X-Server and Mesa is considered safe for use under DRI3/Present.
PTB-INFO: Using GLEW version 2.0.0 for automatic detection of OpenGL extensions...
PTB-INFO: Window uses DRI3/Present for visual stimulus presentation.
PTB-INFO: Using GLX_MESA_swap_control extension for control of vsync.
PTB-INFO: INTEL_swap_event support for additional swap completion correctness checks enabled.


OpenGL-Vendor / renderer / version are: X.Org - AMD Radeon (TM) Pro WX 5100 Graphics (POLARIS10 / DRM 3.23.0 / 4.15.0-33-generic, LLVM 6.0.0) - 3.0 Mesa 18.0.5


OpenGL-Extensions are: GL_AMD_conservative_depth GL_AMD_draw_buffers_blend GL_AMD_performance_monitor GL_AMD_pinned_memory GL_AMD_seamless_cubemap_per_texture GL_AMD_shader_stencil_export GL_AMD_shader_trinary_minmax GL_ANGLE_texture_compression_dxt3 GL_ANGLE_texture_compression_dxt5 GL_APPLE_packed_pixels GL_ARB_ES2_compatibility GL_ARB_ES3_compatibility GL_ARB_arrays_of_arrays GL_ARB_base_instance GL_ARB_bindless_texture GL_ARB_blend_func_extended GL_ARB_buffer_storage GL_ARB_clear_buffer_object GL_ARB_clear_texture GL_ARB_clip_control GL_ARB_color_buffer_float GL_ARB_compressed_texture_pixel_storage GL_ARB_compute_shader GL_ARB_compute_variable_group_size GL_ARB_conditional_render_inverted GL_ARB_conservative_depth GL_ARB_copy_buffer GL_ARB_copy_image GL_ARB_cull_distance GL_ARB_debug_output GL_ARB_depth_buffer_float GL_ARB_depth_clamp GL_ARB_depth_texture GL_ARB_derivative_control GL_ARB_draw_buffers GL_ARB_draw_buffers_blend GL_ARB_draw_elements_base_vertex GL_ARB_draw_instanced GL_ARB_explicit_attrib_location GL_ARB_explicit_uniform_location GL_ARB_fragment_coord_conventions GL_ARB_fragment_program GL_ARB_fragment_program_shadow GL_ARB_fragment_shader GL_ARB_framebuffer_no_attachments GL_ARB_framebuffer_object GL_ARB_framebuffer_sRGB GL_ARB_get_program_binary GL_ARB_get_texture_sub_image GL_ARB_half_float_pixel GL_ARB_half_float_vertex GL_ARB_instanced_arrays GL_ARB_internalformat_query GL_ARB_internalformat_query2 GL_ARB_invalidate_subdata GL_ARB_map_buffer_alignment GL_ARB_map_buffer_range GL_ARB_multi_bind GL_ARB_multisample GL_ARB_multitexture GL_ARB_occlusion_query GL_ARB_occlusion_query2 GL_ARB_pipeline_statistics_query GL_ARB_pixel_buffer_object GL_ARB_point_parameters GL_ARB_point_sprite GL_ARB_polygon_offset_clamp GL_ARB_program_interface_query GL_ARB_provoking_vertex GL_ARB_query_buffer_object GL_ARB_robust_buffer_access_behavior GL_ARB_robustness GL_ARB_sample_shading GL_ARB_sampler_objects GL_ARB_seamless_cube_map GL_ARB_seamless_cubemap_per_texture GL_ARB_separate_shader_objects GL_ARB_shader_atomic_counter_ops GL_ARB_shader_atomic_counters GL_ARB_shader_ballot GL_ARB_shader_bit_encoding GL_ARB_shader_clock GL_ARB_shader_draw_parameters GL_ARB_shader_group_vote GL_ARB_shader_image_load_store GL_ARB_shader_image_size GL_ARB_shader_objects GL_ARB_shader_precision GL_ARB_shader_stencil_export GL_ARB_shader_storage_buffer_object GL_ARB_shader_texture_image_samples GL_ARB_shader_texture_lod GL_ARB_shading_language_100 GL_ARB_shading_language_420pack GL_ARB_shading_language_packing GL_ARB_shadow GL_ARB_sparse_buffer GL_ARB_stencil_texturing GL_ARB_sync GL_ARB_texture_barrier GL_ARB_texture_border_clamp GL_ARB_texture_buffer_object GL_ARB_texture_buffer_object_rgb32 GL_ARB_texture_buffer_range GL_ARB_texture_compression GL_ARB_texture_compression_bptc GL_ARB_texture_compression_rgtc GL_ARB_texture_cube_map GL_ARB_texture_cube_map_array GL_ARB_texture_env_add GL_ARB_texture_env_combine GL_ARB_texture_env_crossbar GL_ARB_texture_env_dot3 GL_ARB_texture_filter_anisotropic GL_ARB_texture_float GL_ARB_texture_gather GL_ARB_texture_mirror_clamp_to_edge GL_ARB_texture_mirrored_repeat GL_ARB_texture_multisample GL_ARB_texture_non_power_of_two GL_ARB_texture_query_levels GL_ARB_texture_query_lod GL_ARB_texture_rectangle GL_ARB_texture_rg GL_ARB_texture_rgb10_a2ui GL_ARB_texture_stencil8 GL_ARB_texture_storage GL_ARB_texture_storage_multisample GL_ARB_texture_swizzle GL_ARB_texture_view GL_ARB_timer_query GL_ARB_transform_feedback2 GL_ARB_transform_feedback3 GL_ARB_transform_feedback_instanced GL_ARB_transform_feedback_overflow_query GL_ARB_transpose_matrix GL_ARB_uniform_buffer_object GL_ARB_vertex_array_bgra GL_ARB_vertex_array_object GL_ARB_vertex_attrib_binding GL_ARB_vertex_buffer_object GL_ARB_vertex_program GL_ARB_vertex_shader GL_ARB_vertex_type_10f_11f_11f_rev GL_ARB_vertex_type_2_10_10_10_rev GL_ARB_window_pos GL_ATI_blend_equation_separate GL_ATI_draw_buffers GL_ATI_fragment_shader GL_ATI_meminfo GL_ATI_separate_stencil GL_ATI_texture_compression_3dc GL_ATI_texture_env_combine3 GL_ATI_texture_float GL_ATI_texture_mirror_once GL_EXT_abgr GL_EXT_bgra GL_EXT_blend_color GL_EXT_blend_equation_separate GL_EXT_blend_func_separate GL_EXT_blend_minmax GL_EXT_blend_subtract GL_EXT_compiled_vertex_array GL_EXT_copy_texture GL_EXT_depth_bounds_test GL_EXT_draw_buffers2 GL_EXT_draw_instanced GL_EXT_draw_range_elements GL_EXT_fog_coord GL_EXT_framebuffer_blit GL_EXT_framebuffer_multisample GL_EXT_framebuffer_multisample_blit_scaled GL_EXT_framebuffer_object GL_EXT_framebuffer_sRGB GL_EXT_gpu_program_parameters GL_EXT_memory_object GL_EXT_memory_object_fd GL_EXT_multi_draw_arrays GL_EXT_packed_depth_stencil GL_EXT_packed_float GL_EXT_packed_pixels GL_EXT_pixel_buffer_object GL_EXT_point_parameters GL_EXT_polygon_offset GL_EXT_polygon_offset_clamp GL_EXT_provoking_vertex GL_EXT_rescale_normal GL_EXT_secondary_color GL_EXT_separate_specular_color GL_EXT_shader_integer_mix GL_EXT_shadow_funcs GL_EXT_stencil_two_side GL_EXT_stencil_wrap GL_EXT_subtexture GL_EXT_texture GL_EXT_texture3D GL_EXT_texture_array GL_EXT_texture_compression_dxt1 GL_EXT_texture_compression_latc GL_EXT_texture_compression_rgtc GL_EXT_texture_compression_s3tc GL_EXT_texture_cube_map GL_EXT_texture_edge_clamp GL_EXT_texture_env_add GL_EXT_texture_env_combine GL_EXT_texture_env_dot3 GL_EXT_texture_filter_anisotropic GL_EXT_texture_integer GL_EXT_texture_lod_bias GL_EXT_texture_mirror_clamp GL_EXT_texture_object GL_EXT_texture_rectangle GL_EXT_texture_sRGB GL_EXT_texture_sRGB_decode GL_EXT_texture_shared_exponent GL_EXT_texture_snorm GL_EXT_texture_swizzle GL_EXT_timer_query GL_EXT_transform_feedback GL_EXT_vertex_array GL_EXT_vertex_array_bgra GL_IBM_multimode_draw_arrays GL_IBM_rasterpos_clip GL_IBM_texture_mirrored_repeat GL_INGR_blend_func_separate GL_KHR_context_flush_control GL_KHR_debug GL_KHR_no_error GL_KHR_robust_buffer_access_behavior GL_KHR_robustness GL_MESA_pack_invert GL_MESA_shader_integer_functions GL_MESA_texture_signed_rgba GL_MESA_window_pos GL_NVX_gpu_memory_info GL_NV_blend_square GL_NV_conditional_render GL_NV_depth_clamp GL_NV_fog_distance GL_NV_light_max_exponent GL_NV_packed_depth_stencil GL_NV_primitive_restart GL_NV_texgen_reflection GL_NV_texture_barrier GL_NV_texture_env_combine4 GL_NV_texture_rectangle GL_NV_vdpau_interop GL_OES_EGL_image GL_OES_read_format GL_S3_s3tc GL_SGIS_generate_mipmap GL_SGIS_texture_border_clamp GL_SGIS_texture_edge_clamp GL_SGIS_texture_lod GL_SUN_multi_draw_arrays 



PTB-INFO: OpenGL-Renderer is X.Org :: AMD Radeon (TM) Pro WX 5100 Graphics (POLARIS10 / DRM 3.23.0 / 4.15.0-33-generic, LLVM 6.0.0) :: 3.0 Mesa 18.0.5
PTB-INFO: VBL startline = 1080 , VBL Endline = 1123
PTB-INFO: Measured monitor refresh interval from beamposition = 9.995529 ms [100.044734 Hz].
PTB-INFO: Will try to use OS-Builtin OpenML sync control support for accurate Flip timestamping.
PTB-INFO: Measured monitor refresh interval from VBLsync = 9.995604 ms [100.043984 Hz]. (50 valid samples taken, stddev=0.000576 ms.)
PTB-INFO: Reported monitor refresh interval from operating system = 9.995802 ms [100.042000 Hz].
PTB-INFO: Small deviations between reported values are normal and no reason to worry.
PTB-INFO: Psychtoolbox imaging pipeline starting up for window with requested imagingmode 5121 ...
PTB-INFO: Will use 32 bits per color component floating point framebuffer for stimulus drawing. Alpha blending should work correctly.
PTB-INFO: Will use 32 bits per color component floating point framebuffer for stimulus post-processing (if any).
PTB-INFO: Disabled color clamping via hardware.

---&gt; screenManager: Previous OpenGL blending was GL_ONE | GL_ZERO
---&gt; screenManager: OpenGL blending now set to GL_SRC_ALPHA | GL_ONE_MINUS_SRC_ALPHA
Building a vertex shader:Reading shader from file /home/psychww/Code/Psychtoolbox-3/Psychtoolbox/PsychOpenGL/PsychGLSLShaders/BasicSineGratingShader.vert.txt ...
Building a fragment shader:Reading shader from file /home/psychww/Code/Psychtoolbox-3/Psychtoolbox/PsychOpenGL/PsychGLSLShaders/ApertureSineGratingShader.frag.txt ...
PTB-INFO: GLSL fragment filtershader created for high quality texture filtering in high-precision unclamped color mode
Compiling all shaders matching BasicSineGratingShader * into a GLSL program.
Building a fragment shader:Reading shader from file /home/psychww/Code/Psychtoolbox-3/Psychtoolbox/PsychOpenGL/PsychGLSLShaders/BasicSineGratingShader.frag.txt ...
Building a vertex shader:Reading shader from file /home/psychww/Code/Psychtoolbox-3/Psychtoolbox/PsychOpenGL/PsychGLSLShaders/BasicSineGratingShader.vert.txt ...
Compiling all shaders matching SineGratingSmoothedApertureShader * into a GLSL program.
Building a fragment shader:Reading shader from file /home/psychww/Code/Psychtoolbox-3/Psychtoolbox/PsychOpenGL/PsychGLSLShaders/SineGratingSmoothedApertureShader.frag.txt ...
Building a vertex shader:Reading shader from file /home/psychww/Code/Psychtoolbox-3/Psychtoolbox/PsychOpenGL/PsychGLSLShaders/SineGratingSmoothedApertureShader.vert.txt ...
Building a vertex shader:Reading shader from file /home/psychww/Code/Psychtoolbox-3/Psychtoolbox/PsychOpenGL/PsychGLSLShaders/BasicSineGratingShader.vert.txt ...
Building a fragment shader:Reading shader from file /home/psychww/Code/Psychtoolbox-3/Psychtoolbox/PsychOpenGL/PsychGLSLShaders/ApertureSineGratingShader.frag.txt ...
Compiling all shaders matching BasicSineGratingShader * into a GLSL program.
Building a fragment shader:Reading shader from file /home/psychww/Code/Psychtoolbox-3/Psychtoolbox/PsychOpenGL/PsychGLSLShaders/BasicSineGratingShader.frag.txt ...
Building a vertex shader:Reading shader from file /home/psychww/Code/Psychtoolbox-3/Psychtoolbox/PsychOpenGL/PsychGLSLShaders/BasicSineGratingShader.vert.txt ...
Building a vertex shader:Reading shader from file /home/psychww/Code/Psychtoolbox-3/Psychtoolbox/PsychOpenGL/PsychGLSLShaders/BasicSineGratingShader.vert.txt ...
Building a fragment shader:Reading shader from file /home/psychww/Code/Psychtoolbox-3/Psychtoolbox/PsychOpenGL/PsychGLSLShaders/ApertureSineGratingShader.frag.txt ...
Building a vertex shader:Reading shader from file /home/psychww/Code/psychophysical_experiments/smoothdisc.vert.txt ...
Building a fragment shader:Reading shader from file /home/psychww/Code/psychophysical_experiments/smoothdisc.frag.txt ...
---&gt; ioManager#18ADF1C09: Constructor parsing input argument | name
---&gt; ioManager#18ADF1F34: Constructor parsing input argument | name

===&gt;&gt;&gt; Warming up the GPU and I/O systems... &lt;&lt;&lt;===
START @B: 1 | R: 1 [1/24] | isBlank: 1 | Time: 0.000 (0) | V: 7 | / angle: 45.00 / contrast: 0.40 / xPosition: -3.00

@B: 1 | R: 1 [1/24] | isBlank: 1 | Time: 0.000 (2) | V: 7 | / angle: 45.00 / contrast: 0.40 / xPosition: -3.00

IS TIME: 1
@B: 1 | R: 2 [2/24] | isBlank: 1 | Time: 2.259 (227) | V: 4 | / angle: 0.00 / contrast: 0.40 / xPosition: 3.00

IS TIME: 1
@B: 1 | R: 3 [3/24] | isBlank: 1 | Time: 5.268 (527) | V: 3 | / angle: 0.00 / contrast: 0.40 / xPosition: -3.00

IS TIME: 1
@B: 1 | R: 4 [4/24] | isBlank: 1 | Time: 8.276 (827) | V: 10 | / angle: 90.00 / contrast: 0.10 / xPosition: 3.00

IS TIME: 1
@B: 1 | R: 5 [5/24] | isBlank: 1 | Time: 11.285 (1127) | V: 9 | / angle: 90.00 / contrast: 0.10 / xPosition: -3.00

IS TIME: 1
@B: 1 | R: 6 [6/24] | isBlank: 1 | Time: 14.294 (1427) | V: 2 | / angle: 0.00 / contrast: 0.10 / xPosition: 3.00

IS TIME: 1
@B: 1 | R: 7 [7/24] | isBlank: 1 | Time: 17.292 (1727) | V: 1 | / angle: 0.00 / contrast: 0.10 / xPosition: -3.00


---&gt; screenManager: RESET GAMMA TABLES

---&gt; screenManager: RESET GAMMA TABLES
---&gt; screenManager: RESET OPENGL BLEND MODE to GL_ONE &amp; GL_ZERO


INFO: PTB's Screen('Flip', 10) command seems to have missed the requested stimulus presentation deadline
INFO: a total of 7 times out of a total of 2032 flips during this session.

INFO: This number is fairly accurate (and indicative of real timing problems in your own code or your system)
INFO: if you provided requested stimulus onset times with the 'when' argument of Screen('Flip', window [, when]);
INFO: If you called Screen('Flip', window); without the 'when' argument, this count is more of a ''mild'' indicator
INFO: of timing behaviour than a hard reliable measurement. Large numbers may indicate problems and should at least
INFO: deserve your closer attention. Cfe. 'help SyncTrouble', the FAQ section at www.psychtoolbox.org and the
INFO: examples in the PDF presentation in PsychDocumentation/Psychtoolbox3-Slides.pdf for more info and timing tips.

</pre><p>Plot a timing log of every frame against the stimulus on/off times:</p><pre class="codeinput">getRunLog(rExp);
</pre><img vspace="5" hspace="5" src="optickatest_02.png" alt=""> <p>The image above is a graphical timing plot of every frame and whether any frames were dropped during stimulus presentation. This will not consider dropped frames during the GPU warming or inter trial time as dropped as the display is blank and we are using absolute time values for our trial transitions. Opticka actually resets and updates the stimulus objects on the second and subsequent frames of the inter trial blank, this forces any computation of stimulus parameter to when it doesn't matter; but note for complex stimuli a frame or two may be dropped during the blank and so ensure you set the inter trial time &gt; than the dropped frame delay!</p><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2018a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Demonstration of a command-driven setup of an Opticka Experiment.
% Opticka is an object oriented framework/GUI for the
% Psychophysics toolbox, allowing randomised interleaved presentation of 
% parameter varying stimuli specified in experimenter-relevant values. 
% It is designed to work on OS X, Windows (currently no digital I/O) 
% or Linux, and can interface via strobed words (using a cheap and 
% very reliable LabJack) and ethernet with external harware for 
% recording neurophysiological data.
% In this example, Stimulus objects (myStims class cell array), 
% stimulus sequence variables (myTask object), and 
% screenManager (myScreen object) are passed to the
% runExperiment object for final display. Opticka also has a UI (type
% opticka in the command window), which is a visual manager of the objects
% introduced here. The UI also controls other functions such as
% calibration, protocol loading/saving and communication with
% neurophysiological equipment via LabJack and ethernet. There is also an
% independent receptive field mapper (rfMapper) that uses mouse control to probe
% receptive fields and generate drawn hand maps.
%
% The source of this file can be found at:
% <https://github.com/iandol/opticka/blob/master/optickatest.m>

%% Initial clear up of previous runs
% Make sure we start in a clean environment, not essential
clear myStims myTask myScreen rExp
sca %PTB screen clear all

%% Stimulus Initialisation
% These set up the 10 different stimuli. Please note that values are in
% degrees, cycles/deg, deg/s etc. Colour is repestend using floating point
% values from 0 - 1 and all objects accept an opacity (alpha) value.
% Each stimulus is a class object with a series of properties ('sf',
% 'colour' etc.) that you can set up by simply passing property name : value pairs 
% into the stimulus class. You can also pass these in as a structure if you prefer. 
% If you do not pass any properties, default values will be used without problems.

%%
% First we create a stimulus manager that collects and handles groups of
% stimuli as if they were a single 'thing', so for example when you use the
% draw method on a stimulus manager, it tells each of its child stimuli to
% draw in turn
myStims = metaStimulus();

%%
% The first six stimuli are gratings / gabors of varying kinds.
myStims{1}=gratingStimulus('sf',1,'contrast',0.5,'size',1,'tf',0,'angle',30,...
	'gabor', 0, 'mask', 1);

myStims{2}=gratingStimulus('sf',3,'contrast',0.5,'tf',1,'size',3,'xPosition',-3,...
	'yPosition',-4,'gabor',1,'mask',0);

myStims{3}=gratingStimulus('sf',1,'contrast',0.5,'size',3,'angle',45,'xPosition',-2,...
	'yPosition',2,'gabor',0,'mask',1,'sigma',15,'speed',2);

myStims{4}=gratingStimulus('sf',1,'contrast',0.5,'tf',0,'size',2,'xPosition',-3,...
	'yPosition',-3,'gabor',0,'mask',1,'speed',2);

myStims{5}=gratingStimulus('sf',1,'contrast',0.25,'colour',[0.6 0.3 0.3],'tf',0.1,...
	'size',2,'xPosition',3,'yPosition',0,'gabor',0,'mask',0);

myStims{6}=gratingStimulus('sf',1,'contrast',0.5,'colour',[0.4 0.4 0.6],'tf',1,...
	'driftDirection',-1,'size',2,'xPosition',4,'yPosition',-4,'gabor',0,'mask',1);

%%
% A simple bar: bars can be solid in colour or have random texture 
% (try setting 'type' to 'random'). This is an opaque solid yellow bar 
% moving at 4deg/s. Notice the startPosition is -4; 
% this means start -4 degrees "behind" start X and Y position, as
% the stimulus is displayed for 2 seconds the bar therefore traverses
% 4degrees behind then 4 degrees past the X and Y position. Also note as we
% will change the angle of this stimulus the geometry is calculated for you
% automatically!
myStims{7}=barStimulus('type','solid','barWidth',1,'barLength',4,'speed',4,'xPosition',0,...
	'yPosition',0,'startPosition',-4,'colour',[.7 .7 .7]);

%%
% coherent dot stimulus; 200 dots moving at 1deg/s with coherence set to 0.5
myStims{8}=dotsStimulus('density',50,'speed',1,'coherence',0.5,'xPosition',4,...
	'yPosition',6,'colour',[1 1 1],'dotType',3,'dotSize',0.1,'colorType','randomBW');

%%
% a simple circular spot, spots can also flash if needed
myStims{9}=discStimulus('speed',2,'xPosition',4,'type','flash',...
	'yPosition',4,'colour',[1 1 1],'size',2,'flashTime',[0.2 0.2]);

%%
% a texture stimulus, by default this loads a picture from the opticka
% stimulus directory; you can rotate it, scale it etc and drift it across screen as
% in this case
myStims{10}=textureStimulus('speed',2,'xPosition',-6,...
	'yPosition',6,'size',0.5);

%% Task Initialisation
% The stimulusSequence class defines a stimulus sequence (task) which is composed
% of randomised stimulus parameter changes (called variables) repeated over
% a set of blocks. A trial is an individual stimulus presentation. This
% example has three different variables changing over 3*2*2 values (12 unique trials) which is
% then repeated over 2 blocks for 24 trials in total
myTask = stimulusSequence; %new stimulusSequence object instance
myTask.nBlocks = 2; %number of blocks
myTask.trialTime = 2; %time of stimulus display: 2 seconds
myTask.isTime = 0.25; %inter trial time: 0.25 seconds
myTask.ibTime=0.5; %inter block time: 1 second
myTask.realTime = false; %we use real time for switching trials, false uses a tick timer updated every flip

%% Variable 1
% Our first variable is angle, applied to stimulus 1 3 7 and 10, randomly
% selected from values of 0 45 and 90 degrees
myTask.nVar(1).name = 'angle';
myTask.nVar(1).stimulus = [1 3 7 10];
myTask.nVar(1).values = [0 45 90];

%% Variable 2
% Our second variable is contrast, applied to stimulus 2 and 3, randomly
% selected from values of 0.025 and 0.1
myTask.nVar(2).name = 'contrast';
myTask.nVar(2).stimulus = [2 3];
myTask.nVar(2).values = [0.1 0.4];

%% Variable 3
% Our third variable is X position, applied to stimulus 2 and 8, randomly
% selected from values of -3 and 3 degrees from visual center of screen
myTask.nVar(3).name = 'xPosition';
myTask.nVar(3).stimulus = [2 8];
myTask.nVar(3).values = [-3 3];
% the next two parameters allow us to link a stimulus with
% an offset; for example you could set stimulus 1 to values [1 2 3]
% and if offsetvalue was 2 and offsetstimulus was 2 then the second
% stimulus would change through [3 4 5]; in this case we offset stimulus 10
% to +1 the values above i.e. [-2 4]
myTask.nVar(3).offsetstimulus = [10];
myTask.nVar(3).offsetvalue = [1];

%% Randomisation
% We call the method to randomise the trials in a block structure
randomiseStimuli(myTask);

%% Visual Trial List
% Lets print out a log of the stimulus properties for every trial
showLog(myTask);

%% Setup screenManager Object
% we initialise the object with parameter options to open the PTB screen
% with. Note distance and pixels per cm define the resultant geometry >
% pixel mappings. You can set several screen parameters, windowing,
% blending etc. hideFlash uses a trick from Mario to set the CLUT to the
% task background colour so you don't see the black flash on PTB screen
% initialisation.
myScreen = screenManager('distance', 57.3,... %display distance from observer
	'pixelsPerCm', 27.5,... %calibration value for screen size/pixel density, see calibrateSize()
	'blend', true,... %enable OpenGL blending, you can also set blend modes when needed
	'windowed', [ ],... %set to a widthxheight for debugging i.e. [800 600]; set to false for fullscreen
	'antiAlias', 0,... %can be set to 4 or 8x oversampling with no dropped frames on OS X ATI 5870
	'bitDepth', 'FloatingPoint32bitIfPossible',... %try 8bit, FloatingPoint16bit FloatingPoint32bit etc.
	'displayPPRefresh', 100, ... %set refresh to 100Hz only if Dispay++ attached
	'hideFlash', false); %mario's gamma trick

%% Setup runExperiment Object
% We now pass our stimulus screen and sequence objects to the
% runExperiment class. runExperiment contains the run() method that actually
% runs the task.
rExp = runExperiment('stimuli', myStims,... %stimulus objects
	'task', myTask,... %task design object
	'screen', myScreen,... %screen manager object
	'debug', false,... %setup screen to complain about sync errors etc.
	'verbose', false); %minimal verbosity

%%
% run our experiment, to exit early, press [q] during the blank
run(rExp);

%%
% Plot a timing log of every frame against the stimulus on/off times:
getRunLog(rExp);

%%
% The image above is a graphical timing plot of every frame and whether any frames
% were dropped during stimulus presentation. This will not consider
% dropped frames during the GPU warming or inter trial time as dropped as the display is
% blank and we are using absolute time values for our trial transitions.
% Opticka actually resets and updates the stimulus objects on the second
% and subsequent frames of the inter trial blank, this forces any computation of
% stimulus parameter to when it doesn't matter; but note
% for complex stimuli a frame or two may be dropped during the blank and so
% ensure you set the inter trial time > than the dropped frame delay!
##### SOURCE END #####
--></body></html>