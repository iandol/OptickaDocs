
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Demonstration of a command-driven setup of an Opticka Experiment.</title><meta name="generator" content="MATLAB 9.2"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2017-06-06"><meta name="DC.source" content="optickatest.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Demonstration of a command-driven setup of an Opticka Experiment.</h1><!--introduction--><p>Opticka is an object oriented framework/GUI for the Psychophysics toolbox, allowing randomised interleaved presentation of parameter varying stimuli specified in experimenter-relevant values. It is designed to work on OS X, Windows (currently no digital I/O) or Linux, and can interface via strobed words (using a cheap and very reliable LabJack) and ethernet with external harware for recording neurophysiological data. In this example, Stimulus objects (myStim class cell array), stimulus sequence variables (myTask object), and screenManager (myScreen object) are passed to the runExperiment object for final display. Opticka also has a UI (type opticka in the command window), which is a visual manager of the objects introduced here. The UI also controls other functions such as calibration, protocol loading/saving and communication with neurophysiological equipment via LabJack and ethernet. There is also an independent receptive field mapper (rfMapper) that uses mouse control to probe receptive fields and generate drawn hand maps.</p><p>The source of this file can be found at: <a href="https://github.com/iandol/opticka/blob/master/optickatest.m">https://github.com/iandol/opticka/blob/master/optickatest.m</a></p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Initial clear up of previous runs</a></li><li><a href="#2">Stimulus Initialisation</a></li><li><a href="#9">Task Initialisation</a></li><li><a href="#10">Variable 1</a></li><li><a href="#11">Variable 2</a></li><li><a href="#12">Variable 3</a></li><li><a href="#13">Randomisation</a></li><li><a href="#14">Visual Trial List</a></li><li><a href="#15">Setup screenManager Object</a></li><li><a href="#16">Setup runExperiment Object</a></li></ul></div><h2 id="1">Initial clear up of previous runs</h2><p>Make sure we start in a clean environment, not essential</p><pre class="codeinput">clear <span class="string">myStim</span> <span class="string">myTask</span> <span class="string">myScreen</span> <span class="string">rExp</span>
sca <span class="comment">%PTB screen clear all</span>
</pre><h2 id="2">Stimulus Initialisation</h2><p>These set up the 10 different stimuli. Please note that values are in degrees, cycles/deg, deg/s etc. Colour is repestend using floating point values from 0 - 1 and all objects accept an opacity (alpha) value. Each stimulus is a class object with a series of properties ('sf', 'colour' etc.) that you can set up by simply passing property name : value pairs into the stimulus class. You can also pass these in as a structure if you prefer. If you do not pass any properties, default values will be used without problems.</p><p>First we create a stimulus manager that collects and handles groups of stimuli as if they were a single 'thing', so for example when you use the draw method on a stimulus manager, it tells each of its child stimuli to draw in turn</p><pre class="codeinput">myStim = metaStimulus();
</pre><p>The first six stimuli are gratings / gabors of varying kinds.</p><pre class="codeinput">myStim{1}=gratingStimulus(<span class="string">'sf'</span>,1,<span class="string">'contrast'</span>,0.5,<span class="string">'size'</span>,1,<span class="string">'tf'</span>,0,<span class="string">'angle'</span>,30,<span class="keyword">...</span>
	<span class="string">'gabor'</span>, 0, <span class="string">'mask'</span>, 1);

myStim{2}=gratingStimulus(<span class="string">'sf'</span>,3,<span class="string">'contrast'</span>,0.5,<span class="string">'tf'</span>,1,<span class="string">'size'</span>,3,<span class="string">'xPosition'</span>,-3,<span class="keyword">...</span>
	<span class="string">'yPosition'</span>,-4,<span class="string">'gabor'</span>,1,<span class="string">'mask'</span>,0);

myStim{3}=gratingStimulus(<span class="string">'sf'</span>,1,<span class="string">'contrast'</span>,0.5,<span class="string">'size'</span>,3,<span class="string">'angle'</span>,45,<span class="string">'xPosition'</span>,-2,<span class="keyword">...</span>
	<span class="string">'yPosition'</span>,2,<span class="string">'gabor'</span>,0,<span class="string">'mask'</span>,1,<span class="string">'sigma'</span>,15,<span class="string">'speed'</span>,2);

myStim{4}=gratingStimulus(<span class="string">'sf'</span>,1,<span class="string">'contrast'</span>,0.5,<span class="string">'tf'</span>,0,<span class="string">'size'</span>,2,<span class="string">'xPosition'</span>,-3,<span class="keyword">...</span>
	<span class="string">'yPosition'</span>,-3,<span class="string">'gabor'</span>,0,<span class="string">'mask'</span>,1,<span class="string">'speed'</span>,2);

myStim{5}=gratingStimulus(<span class="string">'sf'</span>,1,<span class="string">'contrast'</span>,0.25,<span class="string">'colour'</span>,[0.6 0.3 0.3],<span class="string">'tf'</span>,0.1,<span class="keyword">...</span>
	<span class="string">'size'</span>,2,<span class="string">'xPosition'</span>,3,<span class="string">'yPosition'</span>,0,<span class="string">'gabor'</span>,0,<span class="string">'mask'</span>,0);

myStim{6}=gratingStimulus(<span class="string">'sf'</span>,1,<span class="string">'contrast'</span>,0.5,<span class="string">'colour'</span>,[0.4 0.4 0.6],<span class="string">'tf'</span>,1,<span class="keyword">...</span>
	<span class="string">'driftDirection'</span>,-1,<span class="string">'size'</span>,2,<span class="string">'xPosition'</span>,4,<span class="string">'yPosition'</span>,-4,<span class="string">'gabor'</span>,0,<span class="string">'mask'</span>,1);
</pre><p>A simple bar: bars can be solid in colour or have random texture (try setting 'type' to 'random'). This is an opaque solid yellow bar moving at 4deg/s. Notice the startPosition is -4; this means start -4 degrees "behind" start X and Y position, as the stimulus is displayed for 2 seconds the bar therefore traverses 4degrees behind then 4 degrees past the X and Y position. Also note as we will change the angle of this stimulus the geometry is calculated for you automatically!</p><pre class="codeinput">myStim{7}=barStimulus(<span class="string">'type'</span>,<span class="string">'solid'</span>,<span class="string">'barWidth'</span>,1,<span class="string">'barLength'</span>,4,<span class="string">'speed'</span>,4,<span class="string">'xPosition'</span>,0,<span class="keyword">...</span>
	<span class="string">'yPosition'</span>,0,<span class="string">'startPosition'</span>,-4,<span class="string">'colour'</span>,[.7 .7 .7]);
</pre><p>coherent dot stimulus; 200 dots moving at 1deg/s with coherence set to 0.5</p><pre class="codeinput">myStim{8}=dotsStimulus(<span class="string">'density'</span>,50,<span class="string">'speed'</span>,1,<span class="string">'coherence'</span>,0.5,<span class="string">'xPosition'</span>,4,<span class="keyword">...</span>
	<span class="string">'yPosition'</span>,6,<span class="string">'colour'</span>,[1 1 1],<span class="string">'dotSize'</span>,0.1,<span class="string">'colorType'</span>,<span class="string">'randomBW'</span>);
</pre><p>a simple circular spot, spots can also flash if needed</p><pre class="codeinput">myStim{9}=discStimulus(<span class="string">'speed'</span>,2,<span class="string">'xPosition'</span>,4,<span class="string">'type'</span>,<span class="string">'flash'</span>,<span class="keyword">...</span>
	<span class="string">'yPosition'</span>,4,<span class="string">'colour'</span>,[1 1 1],<span class="string">'size'</span>,2,<span class="string">'flashTime'</span>,[0.2 0.2]);
</pre><p>a texture stimulus, by default this loads a picture from the opticka stimulus directory; you can rotate it, scale it etc and drift it across screen as in this case</p><pre class="codeinput">myStim{10}=textureStimulus(<span class="string">'speed'</span>,2,<span class="string">'xPosition'</span>,-6,<span class="keyword">...</span>
	<span class="string">'yPosition'</span>,6,<span class="string">'size'</span>,0.5);
</pre><h2 id="9">Task Initialisation</h2><p>The stimulusSequence class defines a stimulus sequence (task) which is composed of randomised stimulus parameter changes (called variables) repeated over a set of blocks. A trial is an individual stimulus presentation. This example has three different variables changing over 3*2*2 values (12 unique trials) which is then repeated over 2 blocks for 24 trials in total</p><pre class="codeinput">myTask = stimulusSequence; <span class="comment">%new stimulusSequence object instance</span>
myTask.nBlocks = 2; <span class="comment">%number of blocks</span>
myTask.trialTime = 2; <span class="comment">%time of stimulus display: 2 seconds</span>
myTask.isTime = 0.25; <span class="comment">%inter trial time: 0.25 seconds</span>
myTask.ibTime=1; <span class="comment">%inter block time: 1 second</span>
</pre><h2 id="10">Variable 1</h2><p>Our first variable is angle, applied to stimulus 1 3 7 and 10, randomly selected from values of 0 45 and 90 degrees</p><pre class="codeinput">myTask.nVar(1).name = <span class="string">'angle'</span>;
myTask.nVar(1).stimulus = [1 3 7 10];
myTask.nVar(1).values = [0 45 90];
</pre><h2 id="11">Variable 2</h2><p>Our second variable is contrast, applied to stimulus 2 and 3, randomly selected from values of 0.025 and 0.1</p><pre class="codeinput">myTask.nVar(2).name = <span class="string">'contrast'</span>;
myTask.nVar(2).stimulus = [2 3];
myTask.nVar(2).values = [0.1 0.4];
</pre><h2 id="12">Variable 3</h2><p>Our third variable is X position, applied to stimulus 2 and 8, randomly selected from values of -3 and 3 degrees from visual center of screen</p><pre class="codeinput">myTask.nVar(3).name = <span class="string">'xPosition'</span>;
myTask.nVar(3).stimulus = [2 8];
myTask.nVar(3).values = [-3 3];
<span class="comment">% the next two parameters allow us to link a stimulus with</span>
<span class="comment">% an offset; for example you could set stimulus 1 to values [1 2 3]</span>
<span class="comment">% and if offsetvalue was 2 and offsetstimulus was 2 then the second</span>
<span class="comment">% stimulus would change through [3 4 5]; in this case we offset stimulus 10</span>
<span class="comment">% to +1 the values above i.e. [-2 4]</span>
myTask.nVar(3).offsetstimulus = [10];
myTask.nVar(3).offsetvalue = [1];
</pre><h2 id="13">Randomisation</h2><p>We call the method to randomise the trials in a block structure</p><pre class="codeinput">randomiseStimuli(myTask);
</pre><h2 id="14">Visual Trial List</h2><p>Lets print out a log of the stimulus properties for every trial</p><pre class="codeinput">showLog(myTask);
</pre><img vspace="5" hspace="5" src="optickatest_01.png" style="width:409px;height:576px;" alt=""> <h2 id="15">Setup screenManager Object</h2><p>we initialise the object with parameter options to open the PTB screen with. Note distance and pixels per cm define the resultant geometry &gt; pixel mappings. You can set several screen parameters, windowing, blending etc. hideFlash uses a trick from Mario to set the CLUT to the task background colour so you don't see the black flash on PTB screen initialisation.</p><pre class="codeinput">myScreen = screenManager(<span class="string">'distance'</span>, 57.3,<span class="keyword">...</span><span class="comment"> %display distance from observer</span>
	<span class="string">'pixelsPerCm'</span>, 44,<span class="keyword">...</span><span class="comment"> %calibration value for screen size/pixel density</span>
	<span class="string">'blend'</span>, true,<span class="keyword">...</span><span class="comment"> %enable OpenGL blending, you can also set blend modes when needed</span>
	<span class="string">'windowed'</span>, [ ],<span class="keyword">...</span><span class="comment"> %set to a widthxheight for debugging i.e. [800 600]; set to false for fullscreen</span>
	<span class="string">'antiAlias'</span>, 0,<span class="keyword">...</span><span class="comment"> %can be set to 4 or 8x oversampling with no dropped frames on OS X ATI 5870</span>
	<span class="string">'bitDepth'</span>, <span class="string">'8bit'</span>,<span class="keyword">...</span><span class="comment"> %try 8bit, FloatingPoint16bit FloatingPoint32bit</span>
	<span class="string">'hideFlash'</span>, false); <span class="comment">%mario's gamma trick</span>
</pre><h2 id="16">Setup runExperiment Object</h2><p>We now pass our stimulus screen and sequence objects to the runExperiment class. runExperiment contains the run class that actually runs the task.</p><pre class="codeinput">rExp = runExperiment(<span class="string">'stimuli'</span>, myStim,<span class="keyword">...</span><span class="comment"> %stimulus objects</span>
	<span class="string">'task'</span>, myTask,<span class="keyword">...</span><span class="comment"> %task design object</span>
	<span class="string">'screen'</span>, myScreen,<span class="keyword">...</span><span class="comment"> %screen manager object</span>
	<span class="string">'debug'</span>, true,<span class="keyword">...</span><span class="comment"> %setup screen to complain about sync errors etc.</span>
	<span class="string">'verbose'</span>, false); <span class="comment">%minimal verbosity</span>
</pre><p>run our experiment, to exit early, press the right (OS X) or middle (Win/Linux) mouse button</p><pre class="codeinput">run(rExp);
</pre><pre class="codeoutput">---&gt; labJack: labJack running in silent mode... | CONSTRUCTOR Method

---&gt; screenManager: Skipping Sync Tests etc.
PTB-INFO: All display tests and calibrations disabled. Assuming a refresh interval of 60.000000 Hz. Timing will be inaccurate!
PTB-ERROR: VBL kernel-level timestamp queries broken on your setup [Impossible order of events]!
PTB-ERROR: Will disable them for now until the problem is resolved. You may want to restart Matlab and retry.
PTB-ERROR: postflip - time_at_swapcompletion == 0.004617 secs.
PTB-ERROR: Btw. if you are running in windowed mode, this is not unusual -- timestamping doesn't work well in windowed mode...

---&gt; screenManager: Initial OpenGL blending set to GL_SRC_ALPHA | GL_ONE_MINUS_SRC_ALPHA
Building a vertex shader:Reading shader from file /Users/ian/Code/Psychtoolbox-3/Psychtoolbox/PsychOpenGL/PsychGLSLShaders/BasicSineGratingShader.vert.txt ...
Building a fragment shader:Reading shader from file /Users/ian/Code/Psychtoolbox-3/Psychtoolbox/PsychOpenGL/PsychGLSLShaders/ApertureSineGratingShader.frag.txt ...
Compiling all shaders matching BasicSineGratingShader * into a GLSL program.
Building a fragment shader:Reading shader from file /Users/ian/Code/Psychtoolbox-3/Psychtoolbox/PsychOpenGL/PsychGLSLShaders/BasicSineGratingShader.frag.txt ...
Building a vertex shader:Reading shader from file /Users/ian/Code/Psychtoolbox-3/Psychtoolbox/PsychOpenGL/PsychGLSLShaders/BasicSineGratingShader.vert.txt ...
Building a vertex shader:Reading shader from file /Users/ian/Code/opticka/stimuli/smoothedaperture.vert.txt ...
Building a fragment shader:Reading shader from file /Users/ian/Code/opticka/stimuli/smoothedaperture.frag.txt ...
Building a vertex shader:Reading shader from file /Users/ian/Code/Psychtoolbox-3/Psychtoolbox/PsychOpenGL/PsychGLSLShaders/BasicSineGratingShader.vert.txt ...
Building a fragment shader:Reading shader from file /Users/ian/Code/Psychtoolbox-3/Psychtoolbox/PsychOpenGL/PsychGLSLShaders/ApertureSineGratingShader.frag.txt ...
Compiling all shaders matching BasicSineGratingShader * into a GLSL program.
Building a fragment shader:Reading shader from file /Users/ian/Code/Psychtoolbox-3/Psychtoolbox/PsychOpenGL/PsychGLSLShaders/BasicSineGratingShader.frag.txt ...
Building a vertex shader:Reading shader from file /Users/ian/Code/Psychtoolbox-3/Psychtoolbox/PsychOpenGL/PsychGLSLShaders/BasicSineGratingShader.vert.txt ...
Building a vertex shader:Reading shader from file /Users/ian/Code/Psychtoolbox-3/Psychtoolbox/PsychOpenGL/PsychGLSLShaders/BasicSineGratingShader.vert.txt ...
Building a fragment shader:Reading shader from file /Users/ian/Code/Psychtoolbox-3/Psychtoolbox/PsychOpenGL/PsychGLSLShaders/ApertureSineGratingShader.frag.txt ...
Building a vertex shader:Reading shader from file /Users/ian/Code/opticka/stimuli/smoothdisc.vert.txt ...
Building a fragment shader:Reading shader from file /Users/ian/Code/opticka/stimuli/smoothdisc.frag.txt ...

---&gt; screenManager: RESET GAMMA TABLES

---&gt; screenManager: RESET GAMMA TABLES


WARNING: This session of your experiment was run by you with the setting Screen('Preference', 'SkipSyncTests', 2).
WARNING: This means that some internal self-tests and calibrations were skipped. Your stimulus presentation timing
WARNING: may have been wrong. This is fine for development and debugging of your experiment, but for running the real
WARNING: study, please make sure to set Screen('Preference', 'SkipSyncTests', 0) for maximum accuracy and reliability.

!!!&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; There were 1 MISSED FRAMES &lt;&lt;&lt; &lt;&lt;&lt; &lt;&lt;&lt;!!!
</pre><p>Plot a timing log of every frame against the stimulus on/off times:</p><pre class="codeinput">getRunLog(rExp);
</pre><img vspace="5" hspace="5" src="optickatest_02.png" style="width:560px;height:1075px;" alt=""> <p>The image above is a graphical timing plot of every frame and whether any frames were dropped during stimulus presentation. This will not consider dropped frames during the GPU warming or inter trial time as dropped as the display is blank and we are using absolute time values for our trial transitions. Opticka actually resets and updates the stimulus objects on the second and subsequent frames of the inter trial blank, this forces any computation of stimulus parameter to when it doesn't matter; but note for complex stimuli a frame or two may be dropped during the blank and so ensure you set the inter trial time &gt; than the dropped frame delay!</p><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2017a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Demonstration of a command-driven setup of an Opticka Experiment.
% Opticka is an object oriented framework/GUI for the
% Psychophysics toolbox, allowing randomised interleaved presentation of 
% parameter varying stimuli specified in experimenter-relevant values. 
% It is designed to work on OS X, Windows (currently no digital I/O) 
% or Linux, and can interface via strobed words (using a cheap and 
% very reliable LabJack) and ethernet with external harware for 
% recording neurophysiological data.
% In this example, Stimulus objects (myStim class cell array), 
% stimulus sequence variables (myTask object), and 
% screenManager (myScreen object) are passed to the
% runExperiment object for final display. Opticka also has a UI (type
% opticka in the command window), which is a visual manager of the objects
% introduced here. The UI also controls other functions such as
% calibration, protocol loading/saving and communication with
% neurophysiological equipment via LabJack and ethernet. There is also an
% independent receptive field mapper (rfMapper) that uses mouse control to probe
% receptive fields and generate drawn hand maps.
%
% The source of this file can be found at:
% <https://github.com/iandol/opticka/blob/master/optickatest.m>

%% Initial clear up of previous runs
% Make sure we start in a clean environment, not essential
clear myStim myTask myScreen rExp
sca %PTB screen clear all

%% Stimulus Initialisation
% These set up the 10 different stimuli. Please note that values are in
% degrees, cycles/deg, deg/s etc. Colour is repestend using floating point
% values from 0 - 1 and all objects accept an opacity (alpha) value.
% Each stimulus is a class object with a series of properties ('sf',
% 'colour' etc.) that you can set up by simply passing property name : value pairs 
% into the stimulus class. You can also pass these in as a structure if you prefer. 
% If you do not pass any properties, default values will be used without problems.

%%
% First we create a stimulus manager that collects and handles groups of
% stimuli as if they were a single 'thing', so for example when you use the
% draw method on a stimulus manager, it tells each of its child stimuli to
% draw in turn
myStim = metaStimulus();

%%
% The first six stimuli are gratings / gabors of varying kinds.
myStim{1}=gratingStimulus('sf',1,'contrast',0.5,'size',1,'tf',0,'angle',30,...
	'gabor', 0, 'mask', 1);

myStim{2}=gratingStimulus('sf',3,'contrast',0.5,'tf',1,'size',3,'xPosition',-3,...
	'yPosition',-4,'gabor',1,'mask',0);

myStim{3}=gratingStimulus('sf',1,'contrast',0.5,'size',3,'angle',45,'xPosition',-2,...
	'yPosition',2,'gabor',0,'mask',1,'sigma',15,'speed',2);

myStim{4}=gratingStimulus('sf',1,'contrast',0.5,'tf',0,'size',2,'xPosition',-3,...
	'yPosition',-3,'gabor',0,'mask',1,'speed',2);

myStim{5}=gratingStimulus('sf',1,'contrast',0.25,'colour',[0.6 0.3 0.3],'tf',0.1,...
	'size',2,'xPosition',3,'yPosition',0,'gabor',0,'mask',0);

myStim{6}=gratingStimulus('sf',1,'contrast',0.5,'colour',[0.4 0.4 0.6],'tf',1,...
	'driftDirection',-1,'size',2,'xPosition',4,'yPosition',-4,'gabor',0,'mask',1);

%%
% A simple bar: bars can be solid in colour or have random texture 
% (try setting 'type' to 'random'). This is an opaque solid yellow bar 
% moving at 4deg/s. Notice the startPosition is -4; 
% this means start -4 degrees "behind" start X and Y position, as
% the stimulus is displayed for 2 seconds the bar therefore traverses
% 4degrees behind then 4 degrees past the X and Y position. Also note as we
% will change the angle of this stimulus the geometry is calculated for you
% automatically!
myStim{7}=barStimulus('type','solid','barWidth',1,'barLength',4,'speed',4,'xPosition',0,...
	'yPosition',0,'startPosition',-4,'colour',[.7 .7 .7]);

%%
% coherent dot stimulus; 200 dots moving at 1deg/s with coherence set to 0.5
myStim{8}=dotsStimulus('density',50,'speed',1,'coherence',0.5,'xPosition',4,...
	'yPosition',6,'colour',[1 1 1],'dotSize',0.1,'colorType','randomBW');

%%
% a simple circular spot, spots can also flash if needed
myStim{9}=discStimulus('speed',2,'xPosition',4,'type','flash',...
	'yPosition',4,'colour',[1 1 1],'size',2,'flashTime',[0.2 0.2]);

%%
% a texture stimulus, by default this loads a picture from the opticka
% stimulus directory; you can rotate it, scale it etc and drift it across screen as
% in this case
myStim{10}=textureStimulus('speed',2,'xPosition',-6,...
	'yPosition',6,'size',0.5);

%% Task Initialisation
% The stimulusSequence class defines a stimulus sequence (task) which is composed
% of randomised stimulus parameter changes (called variables) repeated over
% a set of blocks. A trial is an individual stimulus presentation. This
% example has three different variables changing over 3*2*2 values (12 unique trials) which is
% then repeated over 2 blocks for 24 trials in total
myTask = stimulusSequence; %new stimulusSequence object instance
myTask.nBlocks = 2; %number of blocks
myTask.trialTime = 2; %time of stimulus display: 2 seconds
myTask.isTime = 0.25; %inter trial time: 0.25 seconds
myTask.ibTime=1; %inter block time: 1 second

%% Variable 1
% Our first variable is angle, applied to stimulus 1 3 7 and 10, randomly
% selected from values of 0 45 and 90 degrees
myTask.nVar(1).name = 'angle';
myTask.nVar(1).stimulus = [1 3 7 10];
myTask.nVar(1).values = [0 45 90];

%% Variable 2
% Our second variable is contrast, applied to stimulus 2 and 3, randomly
% selected from values of 0.025 and 0.1
myTask.nVar(2).name = 'contrast';
myTask.nVar(2).stimulus = [2 3];
myTask.nVar(2).values = [0.1 0.4];

%% Variable 3
% Our third variable is X position, applied to stimulus 2 and 8, randomly
% selected from values of -3 and 3 degrees from visual center of screen
myTask.nVar(3).name = 'xPosition';
myTask.nVar(3).stimulus = [2 8];
myTask.nVar(3).values = [-3 3];
% the next two parameters allow us to link a stimulus with
% an offset; for example you could set stimulus 1 to values [1 2 3]
% and if offsetvalue was 2 and offsetstimulus was 2 then the second
% stimulus would change through [3 4 5]; in this case we offset stimulus 10
% to +1 the values above i.e. [-2 4]
myTask.nVar(3).offsetstimulus = [10];
myTask.nVar(3).offsetvalue = [1];

%% Randomisation
% We call the method to randomise the trials in a block structure
randomiseStimuli(myTask);

%% Visual Trial List
% Lets print out a log of the stimulus properties for every trial
showLog(myTask);

%% Setup screenManager Object
% we initialise the object with parameter options to open the PTB screen
% with. Note distance and pixels per cm define the resultant geometry >
% pixel mappings. You can set several screen parameters, windowing,
% blending etc. hideFlash uses a trick from Mario to set the CLUT to the
% task background colour so you don't see the black flash on PTB screen
% initialisation.
myScreen = screenManager('distance', 57.3,... %display distance from observer
	'pixelsPerCm', 44,... %calibration value for screen size/pixel density
	'blend', true,... %enable OpenGL blending, you can also set blend modes when needed
	'windowed', [ ],... %set to a widthxheight for debugging i.e. [800 600]; set to false for fullscreen
	'antiAlias', 0,... %can be set to 4 or 8x oversampling with no dropped frames on OS X ATI 5870
	'bitDepth', '8bit',... %try 8bit, FloatingPoint16bit FloatingPoint32bit
	'hideFlash', false); %mario's gamma trick

%% Setup runExperiment Object
% We now pass our stimulus screen and sequence objects to the
% runExperiment class. runExperiment contains the run class that actually
% runs the task.
rExp = runExperiment('stimuli', myStim,... %stimulus objects
	'task', myTask,... %task design object
	'screen', myScreen,... %screen manager object
	'debug', true,... %setup screen to complain about sync errors etc.
	'verbose', false); %minimal verbosity

%%
% run our experiment, to exit early, press the right (OS X) or middle (Win/Linux) mouse
% button
run(rExp);

%%
% Plot a timing log of every frame against the stimulus on/off times:
getRunLog(rExp);

%%
% The image above is a graphical timing plot of every frame and whether any frames
% were dropped during stimulus presentation. This will not consider
% dropped frames during the GPU warming or inter trial time as dropped as the display is
% blank and we are using absolute time values for our trial transitions.
% Opticka actually resets and updates the stimulus objects on the second
% and subsequent frames of the inter trial blank, this forces any computation of
% stimulus parameter to when it doesn't matter; but note
% for complex stimuli a frame or two may be dropped during the blank and so
% ensure you set the inter trial time > than the dropped frame delay!
##### SOURCE END #####
--></body></html>