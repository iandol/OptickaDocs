
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Demonstration of a command-driven setup of an Opticka MOC Experiment.</title><meta name="generator" content="MATLAB 9.14"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2023-03-31"><meta name="DC.source" content="optickaTest.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Demonstration of a command-driven setup of an Opticka MOC Experiment.</h1><!--introduction--><p>Opticka is an object-oriented framework plus optional GUI for the Psychophysics toolbox, allowing randomised interleaved presentation of parameter-varying stimuli specified in experimenter-relevant values. It is designed to work on Linux, macOS or Windows and can interface via strobed words and ethernet with external harware for recording neurophysiological data.</p><p>In this example of a Methods of Constants (MOC) experiment, stimulus objects (myStims object), stimulus sequence (myTask object), and screenManager (myScreen object) are passed to the runExperiment class to run the experiment.</p><p>Opticka also has a UI (type opticka in the command window), which is a visual manager of the objects introduced here. The UI also controls other functions such as calibration, protocol loading/saving and communication with neurophysiological equipment via LabJack and ethernet. There is also an independent receptive field mapper (rfMapper) that uses mouse control to probe receptive fields for vision experiments and generates drawn hand maps.</p><p>The source of this file can be found at: <a href="https://github.com/iandol/opticka/blob/master/optickatest.m">https://github.com/iandol/opticka/blob/master/optickatest.m</a></p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Initial clear up of previous runs</a></li><li><a href="#2">Stimulus Initialisation</a></li><li><a href="#13">Task Initialisation</a></li><li><a href="#14">Variable 1</a></li><li><a href="#15">Variable 2</a></li><li><a href="#16">Variable 3</a></li><li><a href="#17">Randomisation</a></li><li><a href="#18">Setup screenManager Object</a></li><li><a href="#19">Setup runExperiment Object</a></li><li><a href="#21">Visual Trial List</a></li><li><a href="#24">Manual control</a></li></ul></div><h2 id="1">Initial clear up of previous runs</h2><p>Make sure we start in a clean environment, not essential</p><pre class="codeinput">clear <span class="string">myStims</span> <span class="string">myTask</span> <span class="string">myExp</span> <span class="string">myScreen</span>
sca <span class="comment">%PTB screen clear all</span>
</pre><h2 id="2">Stimulus Initialisation</h2><p>Set up 11 different stimuli. Values are in degrees, cycles/deg, deg/s etc. Colour is represented using floating point values from 0 - 1 and all objects accept an opacity (alpha) value. Each stimulus is a class object with a series of properties ('sf', 'colour' etc.) that you can set up by simply passing property name : value pairs into the stimulus class. You can also pass these in as a structure if you prefer. If you do not pass any properties, default values will be used without problems.</p><p>First we create a stimulus manager object that collects and handles groups of stimuli as if they were a single 'thing', so for example when you use the draw method on a metaStimulus myStims.draw(), it tells each of its child stimuli to draw in order</p><pre class="codeinput">myStims = metaStimulus();
</pre><p>Stimului are made using stimulus classes. Each class inherits from baseStimulus, which has 5 abstract classes ALL stimuli must implement: [1] SETUP(screenManager) - takes a screenManager and sets up the stimulus properties ready for display. [2] DRAW() - draws the stimulus [3] ANIMATE() - for each stimulus class, animate takes speed, tf etc. and updates the position onscreen for the next flip. [4] UPDATE() - if any parameters have changed (size, position, colour etc.), then update ensures all properties are properly updated. [5] RESET() - returns the object back to its pre-setup state.</p><pre class="codeinput"><span class="comment">%The first few stimuli are gratings / gabors of varying kinds.</span>
myStims{1}=gratingStimulus(<span class="string">'sf'</span>, 1, <span class="string">'tf'</span>, 0, <span class="string">'phase'</span>, 90, <span class="string">'contrast'</span>, 0.7, <span class="keyword">...</span>
	<span class="string">'size'</span>, 2, <span class="string">'angle'</span>, -45, <span class="string">'mask'</span>, false, <span class="keyword">...</span>
	<span class="string">'name'</span>, <span class="string">'Standard grating'</span>);

myStims{2}=gaborStimulus(<span class="string">'sf'</span>, 1, <span class="string">'contrast'</span>, 0.75, <span class="string">'tf'</span>, 3, <span class="string">'size'</span>, 3, <span class="string">'angle'</span>, -70,<span class="keyword">...</span>
	<span class="string">'aspectRatio'</span>, 0.5, <span class="string">'xPosition'</span>, 5, <span class="string">'yPosition'</span>, -5,<span class="keyword">...</span>
	<span class="string">'name'</span>, <span class="string">'Gabor'</span>);

myStims{3}=gratingStimulus(<span class="string">'sf'</span>, 2, <span class="string">'tf'</span>, 4, <span class="string">'contrast'</span>, 0.7, <span class="string">'size'</span>, 3, <span class="string">'angle'</span>, 45,<span class="keyword">...</span>
	<span class="string">'xPosition'</span>, 0, <span class="string">'yPosition'</span>, -10, <span class="string">'mask'</span>, true, <span class="string">'sigma'</span>, 30,<span class="keyword">...</span>
	<span class="string">'name'</span>, <span class="string">'Edge-smoothed grating'</span>);

myStims{4}=gratingStimulus(<span class="string">'type'</span>, <span class="string">'square'</span>, <span class="string">'sf'</span>, 1, <span class="string">'contrast'</span>, 1, <span class="keyword">...</span>
	<span class="string">'colour'</span>, [0.5 0.5 0.5], <span class="string">'tf'</span>, 0,<span class="keyword">...</span>
	<span class="string">'size'</span>, 3, <span class="string">'xPosition'</span>, 6, <span class="string">'yPosition'</span>, 0, <span class="keyword">...</span>
	<span class="string">'phaseReverseTime'</span>,0.33, <span class="keyword">...</span>
	<span class="string">'name'</span>, <span class="string">'Squarewave grating'</span>);
</pre><p>This is log gabor filtered noise, based on code shared by Steve Dakin You can control the orientation / SF filtering, and pass an image through it, or let it create a random texture. It can phase reverse using an invert GLSL shader on the texture.</p><pre class="codeinput">myStims{5}=logGaborStimulus(<span class="string">'size'</span>, 3, <span class="string">'xPosition'</span>, 0,<span class="string">'yPosition'</span>, -5,<span class="keyword">...</span>
	<span class="string">'sfPeak'</span>, 3, <span class="string">'sfSigma'</span>, 0.05, <span class="string">'angleSigma'</span>, 20, <span class="string">'seed'</span>, 5,<span class="keyword">...</span>
	<span class="string">'phaseReverseTime'</span>,0.33, <span class="keyword">...</span>
	<span class="string">'name'</span>, <span class="string">'Log Gabor Filtered Noise'</span>);
</pre><p>This is a colour grating where two independant colours can be modulated relative to a base colour, in this case this is a red/green grating modulating from 0.5 background grey.</p><pre class="codeinput">myStims{6}=colourGratingStimulus(<span class="string">'colour'</span>, [1 0 0 1], <span class="string">'colour2'</span>, [0 1 0 1],<span class="keyword">...</span>
	<span class="string">'baseColour'</span>, [0.5 0.5 0.5], <span class="string">'tf'</span>, 1, <span class="string">'size'</span>, 3, <span class="string">'xPosition'</span>, -6, <span class="string">'yPosition'</span>, 0,<span class="keyword">...</span>
	<span class="string">'name'</span>, <span class="string">'Red/green grating'</span>);
</pre><p>coherent dot stimulus; 200 dots moving at 2deg/s with coherence set to 0.25</p><pre class="codeinput">myStims{7}=dotsStimulus(<span class="string">'density'</span>,50,<span class="string">'coherence'</span>,0.25,<span class="string">'xPosition'</span>,4,<span class="keyword">...</span>
	<span class="string">'yPosition'</span>,6,<span class="string">'dotType'</span>,3,<span class="string">'dotSize'</span>,0.1,<span class="string">'colorType'</span>,<span class="string">'randomBW'</span>,<span class="string">'mask'</span>,true,<span class="keyword">...</span>
	<span class="string">'name'</span>,<span class="string">'Coherent dots'</span>);
</pre><p>A simple bar: bars can be solid in colour or have checkerboard/random texture (try setting 'type' to 'random' etc.). This is a bar moving at 4deg/s. Notice the startPosition is -4; this means start -4 degrees "behind" X and Y position, as the stimulus is displayed for 2 seconds the bar therefore traverses 4 degrees behind then 4 degrees past the X and Y position (i.e. drift a bar over a RF location) Also note as we will change the angle of this stimulus the geometry is calculated for you automatically!</p><pre class="codeinput">myStims{8}=barStimulus(<span class="string">'type'</span>,<span class="string">'checkerboard'</span>,<span class="string">'sf'</span>,2,<span class="string">'barWidth'</span>,1,<span class="string">'barHeight'</span>,4,<span class="keyword">...</span>
	<span class="string">'speed'</span>,4,<span class="string">'xPosition'</span>,0,<span class="string">'yPosition'</span>,0,<span class="string">'startPosition'</span>,-4,<span class="string">'phaseReverseTime'</span>,0.33,<span class="keyword">...</span>
	<span class="string">'name'</span>,<span class="string">'Checkerboard bar'</span>);
</pre><p>an edge-smoothed spot; spots can also flash if needed</p><pre class="codeinput">myStims{9}=discStimulus(<span class="string">'type'</span>,<span class="string">'flash'</span>,<span class="string">'speed'</span>,2,<span class="string">'xPosition'</span>,4,<span class="string">'sigma'</span>,40,<span class="keyword">...</span>
	<span class="string">'yPosition'</span>,4,<span class="string">'colour'</span>,[1 1 0],<span class="string">'flashColour'</span>,[0 0 1],<span class="string">'size'</span>,3,<span class="string">'flashTime'</span>,[0.2 0.15],<span class="keyword">...</span>
	<span class="string">'name'</span>,<span class="string">'Flashing disc'</span>);
</pre><p>a picture stimulus, by default this loads a picture from the opticka stimulus directory; you can rotate it, scale it etc and drift it across screen as in this case. Size is in degrees, scaling the whole picture</p><pre class="codeinput">myStims{10}=imageStimulus(<span class="string">'speed'</span>,2,<span class="string">'xPosition'</span>,-10,<span class="string">'yPosition'</span>,10,<span class="string">'size'</span>,4,<span class="keyword">...</span>
	<span class="string">'name'</span>,<span class="string">'Image'</span>);
</pre><p>a picture stimulus, by default this loads a picture from the opticka stimulus directory; you can rotate it, scale it etc and drift it across screen as in this case. Size is in degrees, scaling the whole picture</p><pre class="codeinput">myStims{11}=imageStimulus(<span class="string">'speed'</span>,0,<span class="string">'xPosition'</span>,0,<span class="string">'yPosition'</span>,5,<span class="string">'size'</span>,5,<span class="keyword">...</span>
	<span class="string">'fileName'</span>,[myStims.paths.root <span class="string">'/stimuli/star.png'</span>],<span class="keyword">...</span>
	<span class="string">'modulateColour'</span>,[0.7 0.7 0.2], <span class="string">'name'</span>, <span class="string">'Image'</span>);
</pre><p>a movie stimulus, by default this loads a movie from the opticka stimulus directory; you can rotate it, scale it etc and drift it across screen as in this case. Size is in degrees, scaling the whole movie</p><pre class="codeinput">myStims{12}=movieStimulus(<span class="string">'speed'</span>, 1, <span class="string">'xPosition'</span>, -7, <span class="string">'yPosition'</span>, -10,<span class="keyword">...</span>
	<span class="string">'size'</span>, 4, <span class="string">'name'</span>, <span class="string">'AVI transparent movie'</span>);
</pre><pre class="codeoutput">---&gt; movieStimulus: Didn't find specified file so replacing with default movie!
</pre><h2 id="13">Task Initialisation</h2><p>The taskSequence class defines a stimulus sequence (task) which is composed of randomised stimulus parameter changes (called variables) repeated over a set of blocks. A trial is an individual stimulus presentation. This example has three different variables changing over 3*2*2 values (12 unique trials) which is then repeated over 2 blocks for 24 trials in total.</p><p>NOTE: for more complex behavioural tasks, Opticka uses a finite state machine to generate flexible experimental protocols, see stateMachine() for more details.</p><pre class="codeinput">myTask = taskSequence(); <span class="comment">%new taskSequence object instance</span>
myTask.nBlocks = 2; <span class="comment">%number of blocks</span>
myTask.trialTime = 2; <span class="comment">%time of stimulus display: 2 seconds</span>
myTask.isTime = 0.25; <span class="comment">%inter-trial time: 0.25 seconds</span>
myTask.ibTime=0.5; <span class="comment">%inter-block time: 1 second</span>
myTask.realTime = true; <span class="comment">%we use real time for switching trials, false uses a tick timer updated every flip</span>
</pre><h2 id="14">Variable 1</h2><p>Our first variable is angle, applied to 4 stimuli, randomly selected from values of 0 45 and 90 degrees</p><pre class="codeinput">myTask.nVar(1).name = <span class="string">'angle'</span>;
myTask.nVar(1).stimulus = [1 3 8 10 11 12];
myTask.nVar(1).values = [0 45 90];
<span class="comment">% the next two parameters allow us to link a stimulus with</span>
<span class="comment">% an offset; for example you could set stimulus 1 to values [1 2 3]</span>
<span class="comment">% and if offsetvalue was 2 and offsetstimulus was 2 then the second</span>
<span class="comment">% stimulus would change through [3 4 5];</span>
myTask.nVar(1).offsetstimulus = [5 6];
myTask.nVar(1).offsetvalue = 90;
</pre><h2 id="15">Variable 2</h2><p>Our second variable is contrast, applied to stimuli 2 / 3 / 5, randomly selected from values of 0.025 and 0.1</p><pre class="codeinput">myTask.nVar(2).name = <span class="string">'contrast'</span>;
myTask.nVar(2).stimulus = [2 3 5];
myTask.nVar(2).values = [0.15 0.55];
</pre><h2 id="16">Variable 3</h2><p>Our third variable is X position, applied to stimulus 2 and 7, randomly selected from values of -3 and 3 degrees from visual center of screen</p><pre class="codeinput">myTask.nVar(3).name = <span class="string">'xPosition'</span>;
myTask.nVar(3).stimulus = [2 7];
myTask.nVar(3).values = [-6 6];
<span class="comment">% the next two parameters allow us to link a stimulus with</span>
<span class="comment">% an offset; for example you could set stimulus 1 to values [1 2 3]</span>
<span class="comment">% and if offsetvalue was 2 and offsetstimulus was 2 then the second</span>
<span class="comment">% stimulus would change through [3 4 5]; in this case we offset stimulus 10</span>
<span class="comment">% to +2 the values above i.e. [-4 8]</span>
myTask.nVar(3).offsetstimulus = [10];
myTask.nVar(3).offsetvalue = 2;
</pre><h2 id="17">Randomisation</h2><p>We call the method to randomise the trials in a block structure</p><pre class="codeinput">randomiseTask(myTask);
</pre><pre class="codeoutput">---&gt; taskSequence &lt;taskSequence#165322E1E&gt;: Took 58.923 ms | randomiseTask
</pre><h2 id="18">Setup screenManager Object</h2><p>we initialise the object with parameter options to open the PTB screen with. Note distance and pixels per cm define the resultant geometry &gt; pixel mappings. You can set several screen parameters, windowing, blending etc. hideFlash uses a trick from Mario to set the CLqUT to the task background colour so you don't see the black flash on PTB screen initialisation.</p><pre class="codeinput">myScreen = screenManager(<span class="string">'distance'</span>, 57.3,<span class="keyword">...</span><span class="comment"> %display distance from observer</span>
	<span class="string">'pixelsPerCm'</span>, 36,<span class="keyword">...</span><span class="comment"> %calibration value for pixel density, measure using calibrateSize()</span>
	<span class="string">'backgroundColour'</span>, [0.5 0.5 0.5],<span class="keyword">...</span><span class="comment"> %initial background colour</span>
	<span class="string">'blend'</span>, true,<span class="keyword">...</span><span class="comment"> %enable OpenGL blending, you can also set blend modes when needed</span>
	<span class="string">'debug'</span>, false,<span class="keyword">...</span><span class="comment"> %enable debug mode?</span>
	<span class="string">'windowed'</span>, [],<span class="keyword">...</span><span class="comment"> %set to a widthxheight for debugging i.e. [800 600]; set to empty for fullscreen</span>
	<span class="string">'bitDepth'</span>, <span class="string">'8bit'</span>);
<span class="keyword">if</span> ismac; myScreen.useRetina = true; <span class="keyword">end</span>
</pre><h2 id="19">Setup runExperiment Object</h2><p>We now pass our stimulus screen and sequence objects to the runExperiment class. runExperiment contains the runMOC() method that actually runs the task.</p><pre class="codeinput">myExp = runExperiment(<span class="string">'stimuli'</span>, myStims,<span class="keyword">...</span><span class="comment"> %stimulus objects</span>
	<span class="string">'task'</span>, myTask,<span class="keyword">...</span><span class="comment"> %task design object</span>
	<span class="string">'screen'</span>, myScreen,<span class="keyword">...</span><span class="comment"> %screen manager object</span>
	<span class="string">'debug'</span>, false,<span class="keyword">...</span><span class="comment"> %use debug mode?</span>
	<span class="string">'verbose'</span>, false); <span class="comment">%minimal verbosity</span>
</pre><p>run our method of constants (MOC) experiment; to exit early, press [q] during the interstimulus period.</p><pre class="codeinput">opts.askForComments = false;
runMOC(myExp, opts);
</pre><pre class="codeoutput">---&gt;arduinoManager: Ports available: /dev/ttyS0
---&gt; taskSequence &lt;taskSequence#165322E1E&gt;: Took 21.812 ms | randomiseTask
---&gt; taskSequence.initialise: Initialised!
===&gt;&gt;&gt; Save initial state: /tmp//Simulcra-2023-3-31-14-22-57.mat

---&gt; screenManager: Normal Screen Preferences used.
PsychVulkanCore-ERROR: Vulkan instance creation failed: -1
BitsPlusPlus: Could not find a Bits# config file under [/home/cog5/.Psychtoolbox/BitsSharpConfig.txt]. Assuming a Bits+ device instead of a Bits# is connected.
BitsPlusPlus: Please create a config file under this name if you have a Bits# and want to use it as Bits# instead of as a Bits+.
BitsPlusPlus: The most simple way is to create an empty file. A more robust way is to store the name of the Bits# serial port
BitsPlusPlus: in the first line of the text file, e.g., COM5 [Windows], or /dev/ttyACM0 [Linux] or similar.
---&gt; screenManager: Probing for a Display++...	NO Display++
---&gt; screenManager: Internal processing set to: 8 bits


PTB-INFO: This is Psychtoolbox-3 for GNU/Linux X11, under Matlab 64-Bit (Version 3.0.19 - Build date: Feb 19 2023).
PTB-INFO: OS support status: Linux 6.2.7-060207-generic Supported.
PTB-INFO: Type 'PsychtoolboxVersion' for more detailed version information.
PTB-INFO: Most parts of the Psychtoolbox distribution are licensed to you under terms of the MIT License, with
PTB-INFO: some restrictions. See file 'License.txt' in the Psychtoolbox root folder for the exact licensing conditions.

PTB-INFO: For information about paid support, support memberships and other commercial services, please type
PTB-INFO: 'PsychPaidSupportAndServices'.

PTB-INFO: Connected to NVidia TU104 [GeForce RTX 2070 SUPER] GPU of NV-160 family with 4 display heads.


PTB-INFO: OpenGL-Renderer is NVIDIA Corporation :: NVIDIA GeForce RTX 2070 SUPER/PCIe/SSE2 :: 4.6.0 NVIDIA 525.89.02
PTB-INFO: VBL startline = 1080 , VBL Endline = 1143
PTB-INFO: Measured monitor refresh interval from beamposition = 8.334593 ms [119.981865 Hz].
PTB-INFO: Measured monitor refresh interval from VBLsync = 8.334079 ms [119.989266 Hz]. (50 valid samples taken, stddev=0.030685 ms.)
PTB-INFO: Reported monitor refresh interval from operating system = 8.334653 ms [119.981003 Hz].
PTB-INFO: Small deviations between reported values are normal and no reason to worry.
PTB-INFO: Psychtoolbox imaging pipeline starting up for window with requested imagingmode 1025 ...
PTB-INFO: Will use 8 bits per color component framebuffer for stimulus drawing.
PTB-INFO: Will use 8 bits per color component framebuffer for stimulus post-processing (if any).

---&gt; screenManager: Previous OpenGL blending: GL_ONE | GL_ZERO
---&gt; screenManager: OpenGL blending now: GL_SRC_ALPHA | GL_ONE_MINUS_SRC_ALPHA
Compiling all shaders matching BasicSineGratingShader * into a GLSL program.
Building a fragment shader:Reading shader from file /home/cog5/Code/Psychtoolbox-3/Psychtoolbox/PsychOpenGL/PsychGLSLShaders/BasicSineGratingShader.frag.txt ...
Building a vertex shader:Reading shader from file /home/cog5/Code/Psychtoolbox-3/Psychtoolbox/PsychOpenGL/PsychGLSLShaders/BasicSineGratingShader.vert.txt ...
Compiling all shaders matching NonSymetricGaborShader * into a GLSL program.
Building a fragment shader:Reading shader from file /home/cog5/Code/Psychtoolbox-3/Psychtoolbox/PsychOpenGL/PsychGLSLShaders/NonSymetricGaborShader.frag.txt ...
Building a vertex shader:Reading shader from file /home/cog5/Code/Psychtoolbox-3/Psychtoolbox/PsychOpenGL/PsychGLSLShaders/NonSymetricGaborShader.vert.txt ...
Compiling all shaders matching SineGratingSmoothedApertureShader * into a GLSL program.
Building a fragment shader:Reading shader from file /home/cog5/Code/Psychtoolbox-3/Psychtoolbox/PsychOpenGL/PsychGLSLShaders/SineGratingSmoothedApertureShader.frag.txt ...
Building a vertex shader:Reading shader from file /home/cog5/Code/Psychtoolbox-3/Psychtoolbox/PsychOpenGL/PsychGLSLShaders/SineGratingSmoothedApertureShader.vert.txt ...
Compiling all shaders matching SquareWaveApertureShader * into a GLSL program.
Building a fragment shader:Reading shader from file /home/cog5/Code/Psychtoolbox-3/Psychtoolbox/PsychOpenGL/PsychGLSLShaders/SquareWaveApertureShader.frag.txt ...
Building a vertex shader:Reading shader from file /home/cog5/Code/Psychtoolbox-3/Psychtoolbox/PsychOpenGL/PsychGLSLShaders/SquareWaveApertureShader.vert.txt ...
Compiling all shaders matching SmoothedDiscShader * into a GLSL program.
Building a fragment shader:Reading shader from file /home/cog5/Code/Psychtoolbox-3/Psychtoolbox/PsychOpenGL/PsychGLSLShaders/SmoothedDiscShader.frag.txt ...
Building a vertex shader:Reading shader from file /home/cog5/Code/Psychtoolbox-3/Psychtoolbox/PsychOpenGL/PsychGLSLShaders/SmoothedDiscShader.vert.txt ...
Compiling all shaders matching /home/cog5/Code/opticka/stimuli/invert.frag * into a GLSL program.
Building a fragment shader:Reading shader from file /home/cog5/Code/opticka/stimuli/invert.frag ...
---&gt; Red/green grating &lt;colourGratingStimulus#1653192EE&gt;: Reset sigma to -1 as type=squarewave | SETUP
Compiling all shaders matching ColorGratingShader * into a GLSL program.
Building a fragment shader:Reading shader from file /home/cog5/Code/Psychtoolbox-3/Psychtoolbox/PsychOpenGL/PsychGLSLShaders/ColorGratingShader.frag.txt ...
Building a vertex shader:Reading shader from file /home/cog5/Code/Psychtoolbox-3/Psychtoolbox/PsychOpenGL/PsychGLSLShaders/ColorGratingShader.vert.txt ...
Compiling all shaders matching SmoothedDiscShader * into a GLSL program.
Building a fragment shader:Reading shader from file /home/cog5/Code/Psychtoolbox-3/Psychtoolbox/PsychOpenGL/PsychGLSLShaders/SmoothedDiscShader.frag.txt ...
Building a vertex shader:Reading shader from file /home/cog5/Code/Psychtoolbox-3/Psychtoolbox/PsychOpenGL/PsychGLSLShaders/SmoothedDiscShader.vert.txt ...
Compiling all shaders matching SmoothedDiscShader * into a GLSL program.
Building a fragment shader:Reading shader from file /home/cog5/Code/Psychtoolbox-3/Psychtoolbox/PsychOpenGL/PsychGLSLShaders/SmoothedDiscShader.frag.txt ...
Building a vertex shader:Reading shader from file /home/cog5/Code/Psychtoolbox-3/Psychtoolbox/PsychOpenGL/PsychGLSLShaders/SmoothedDiscShader.vert.txt ...

---&gt;&gt;&gt; movieStimulus: /home/cog5/Code/opticka/stimuli/monkey-dance.avi
	0.92 seconds duration,  frames @ 25.000000 fps, w x h = 320 x 320, in 158ms
	Blocking: 0 | Loop: 1 | Preloadsecs: -1 | Pixelformat:  | Flags: 

===&gt;&gt;&gt; No strobe output I/O...
===&gt; No reward TTLs will be sent...
--&gt; dataConnection: Trying to close local connection... | close Method
--&gt; dataConnection: Cleaning up now... | dataConnection delete Method
--&gt; dataConnection: Trying to close local connection... | close Method
--&gt; dataConnection: Configuring setting in constructor | protocol

===&gt;&gt;&gt; Warming up the GPU and I/O systems... &lt;&lt;&lt;===
PTB-INFO: Movie playback had to drop 1 frames of movie 0 to keep playback in sync.
START @ Blank:1 | B:1 R:1 [1/24] | V: 10 | Time: 0.000 (0)  &gt; angle: 90.000 &gt; contrast: 0.150 &gt;
xPosition: 6.000

===&gt;IN BLANK: Blank:1 | B:1 R:1 [1/24] | V: 10 | Time: 0.000 (1)  &gt; angle: 90.000 &gt; contrast: 0.150 &gt;
xPosition: 6.000
===&gt;IN BLANK: Blank:1 | B:1 R:2 [2/24] | V: 3 | Time: 2.267 (265)  &gt; angle: 0.000 &gt; contrast: 0.550 &gt;
xPosition: -6.000
===&gt;IN BLANK: Blank:1 | B:1 R:3 [3/24] | V: 2 | Time: 5.259 (620)  &gt; angle: 0.000 &gt; contrast: 0.150 &gt;
xPosition: 6.000
===&gt;IN BLANK: Blank:1 | B:1 R:4 [4/24] | V: 5 | Time: 8.260 (979)  &gt; angle: 45.000 &gt; contrast: 0.150 &gt;
xPosition: -6.000
===&gt;IN BLANK: Blank:1 | B:1 R:5 [5/24] | V: 12 | Time: 11.260 (1337)  &gt; angle: 90.000 &gt; contrast: 0.550 &gt;
xPosition: 6.000
===&gt;IN BLANK: Blank:1 | B:1 R:6 [6/24] | V: 11 | Time: 14.261 (1695)  &gt; angle: 90.000 &gt; contrast: 0.550 &gt;
xPosition: -6.000
===&gt;IN BLANK: Blank:1 | B:1 R:7 [7/24] | V: 7 | Time: 17.261 (2054)  &gt; angle: 45.000 &gt; contrast: 0.550 &gt;
xPosition: -6.000
===&gt;IN BLANK: Blank:1 | B:1 R:8 [8/24] | V: 8 | Time: 20.261 (2413)  &gt; angle: 45.000 &gt; contrast: 0.550 &gt;
xPosition: 6.000

---&gt; screenManager: RESET GAMMA TABLES
---&gt; Number of dropped movie frames: 0


---&gt; screenManager 16532CD1F: Closing screen = 1, Win = 10, Kind = 1


INFO: PTB's Screen('Flip', 10) command seems to have missed the requested stimulus presentation deadline
INFO: a total of 26 times out of a total of 2719 flips during this session.

INFO: This number is fairly accurate (and indicative of real timing problems in your own code or your system)
INFO: if you provided requested stimulus onset times with the 'when' argument of Screen('Flip', window [, when]);
INFO: If you called Screen('Flip', window); without the 'when' argument, this count is more of a ''mild'' indicator
INFO: of timing behaviour than a hard reliable measurement. Large numbers may indicate problems and should at least
INFO: deserve your closer attention. Cfe. 'help SyncTrouble', the FAQ section at www.psychtoolbox.org and the
INFO: examples in the PDF presentation in PsychDocumentation/Psychtoolbox3-Slides.pdf for more info and timing tips.



#####################
===&gt;&gt;&gt; SAVED DATA to: /home/cog5/OptickaFiles/SavedData/Simulcra-2023-3-31-14-22-57.mat
#####################


!!!&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; There were 1 MISSED FRAMES &lt;&lt;&lt; &lt;&lt;&lt; &lt;&lt;&lt;!!!
--&gt; dataConnection: Cleaning up now... | dataConnection delete Method
--&gt; dataConnection: Trying to close local connection... | close Method
</pre><h2 id="21">Visual Trial List</h2><p>Lets print out a table of the stimulus properties for every trial</p><pre class="codeinput">showTable(myTask);
</pre><img vspace="5" hspace="5" src="optickaTest_01.png" alt=""> <p>Plot a timing log of every frame against the stimulus on/off times:</p><pre class="codeinput">showTimingLog(myExp);
</pre><img vspace="5" hspace="5" src="optickaTest_02.png" alt=""> <img vspace="5" hspace="5" src="optickaTest_03.png" alt=""> <p>The image above is a graphical timing plot of every frame and whether any frames were dropped during stimulus presentation. This will not consider dropped frames during the GPU warming or inter trial time as dropped as the display is blank and we are using absolute time values for our trial transitions. Opticka actually resets and updates the stimulus objects on the second and subsequent frames of the inter trial blank, this forces any computation of stimulus parameter to when it doesn't matter; but note for complex stimuli a frame or two may be dropped during the blank and so ensure you set the inter trial time &gt; than the dropped frames!</p><h2 id="24">Manual control</h2><p>You don't need to use opticka's stimuli via runExperiment(), you can use them in your own experiments, lets have a quick look here, set runThis to true to run the following code:</p><pre class="codeinput">runThis = false;
<span class="keyword">if</span> ~runThis; <span class="keyword">return</span>; <span class="keyword">end</span>

<span class="comment">% We'll use the movie stimulus, and run it on its own, using its methods</span>
<span class="comment">% to draw() and animate() in a standard PTB loop</span>
WaitSecs(<span class="string">'YieldSecs'</span>,2);
reset(myStims); <span class="comment">% reset them back to their defaults</span>

<span class="comment">%stimulus</span>
myMovie = myStims{12}; <span class="comment">% the movie stimulus from above</span>
myMovie.xPosition = 0; myMovie.yPosition = 0;
myMovie.speed = 5;
myMovie.size = 0; <span class="comment">%if size is zero, then native dimensions are used.</span>
myMovie.direction = 45; <span class="comment">%you can specify the motion direction seperate from texture angle</span>
myMovie.enforceBlending = false; <span class="comment">%not needed as screen will use correct blending mode</span>

<span class="comment">% screen settings</span>
myScreen.backgroundColour = [1 0 0];
myScreen.srcMode = <span class="string">'GL_SRC_ALPHA'</span>;
myScreen.dstMode = <span class="string">'GL_ONE_MINUS_SRC_ALPHA'</span>;
open(myScreen); <span class="comment">%open a screen</span>
setup(myMovie, myScreen); <span class="comment">%setup the stimulus with the screen configuration</span>
<span class="keyword">for</span> i = 1:myScreen.screenVals.fps*2
	draw(myMovie);
	finishDrawing(myScreen);
	animate(myMovie);
	flip(myScreen);
<span class="keyword">end</span>
reset(myMovie);
close(myScreen);
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2023a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Demonstration of a command-driven setup of an Opticka MOC Experiment.
% Opticka is an object-oriented framework plus optional GUI for the
% Psychophysics toolbox, allowing randomised interleaved presentation of
% parameter-varying stimuli specified in experimenter-relevant values. It
% is designed to work on Linux, macOS or Windows and can interface via
% strobed words and ethernet with external harware for recording
% neurophysiological data.
%
% In this example of a Methods of Constants (MOC) experiment, stimulus
% objects (myStims object), stimulus sequence (myTask object), and
% screenManager (myScreen object) are passed to the runExperiment class to
% run the experiment.
% 
% Opticka also has a UI (type opticka in the command window), which is a
% visual manager of the objects introduced here. The UI also controls other
% functions such as calibration, protocol loading/saving and communication
% with neurophysiological equipment via LabJack and ethernet. There is also
% an independent receptive field mapper (rfMapper) that uses mouse control
% to probe receptive fields for vision experiments and generates drawn hand
% maps.
%
% The source of this file can be found at:
% <https://github.com/iandol/opticka/blob/master/optickatest.m>

%% Initial clear up of previous runs
% Make sure we start in a clean environment, not essential
clear myStims myTask myExp myScreen
sca %PTB screen clear all

%% Stimulus Initialisation
% Set up 11 different stimuli. Values are in
% degrees, cycles/deg, deg/s etc. Colour is represented using floating point
% values from 0 - 1 and all objects accept an opacity (alpha) value.
% Each stimulus is a class object with a series of properties ('sf',
% 'colour' etc.) that you can set up by simply passing property name : value pairs 
% into the stimulus class. You can also pass these in as a structure if you prefer. 
% If you do not pass any properties, default values will be used without problems.

%%
% First we create a stimulus manager object that collects and handles groups of
% stimuli as if they were a single 'thing', so for example when you use the
% draw method on a metaStimulus myStims.draw(), it tells each of its child stimuli to draw in order
myStims = metaStimulus();

%%
% Stimului are made using stimulus classes. Each class inherits from
% baseStimulus, which has 5 abstract classes ALL stimuli must implement:
% [1] SETUP(screenManager) - takes a screenManager and sets up the
% stimulus properties ready for display.
% [2] DRAW() - draws the stimulus
% [3] ANIMATE() - for each stimulus class, animate takes speed, tf etc. and
% updates the position onscreen for the next flip.
% [4] UPDATE() - if any parameters have changed (size, position, colour
% etc.), then update ensures all properties are properly updated.
% [5] RESET() - returns the object back to its pre-setup state.
%
%The first few stimuli are gratings / gabors of varying kinds.
myStims{1}=gratingStimulus('sf', 1, 'tf', 0, 'phase', 90, 'contrast', 0.7, ...
	'size', 2, 'angle', -45, 'mask', false, ...
	'name', 'Standard grating');

myStims{2}=gaborStimulus('sf', 1, 'contrast', 0.75, 'tf', 3, 'size', 3, 'angle', -70,...
	'aspectRatio', 0.5, 'xPosition', 5, 'yPosition', -5,...
	'name', 'Gabor');

myStims{3}=gratingStimulus('sf', 2, 'tf', 4, 'contrast', 0.7, 'size', 3, 'angle', 45,...
	'xPosition', 0, 'yPosition', -10, 'mask', true, 'sigma', 30,...
	'name', 'Edge-smoothed grating');

myStims{4}=gratingStimulus('type', 'square', 'sf', 1, 'contrast', 1, ...
	'colour', [0.5 0.5 0.5], 'tf', 0,...
	'size', 3, 'xPosition', 6, 'yPosition', 0, ...
	'phaseReverseTime',0.33, ...
	'name', 'Squarewave grating');

%%
% This is log gabor filtered noise, based on code shared by Steve Dakin
% You can control the orientation / SF filtering, and pass an image
% through it, or let it create a random texture. It can phase reverse using
% an invert GLSL shader on the texture.
myStims{5}=logGaborStimulus('size', 3, 'xPosition', 0,'yPosition', -5,...
	'sfPeak', 3, 'sfSigma', 0.05, 'angleSigma', 20, 'seed', 5,...
	'phaseReverseTime',0.33, ...
	'name', 'Log Gabor Filtered Noise');

%%
% This is a colour grating where two independant colours can be modulated
% relative to a base colour, in this case this is a red/green grating
% modulating from 0.5 background grey.
myStims{6}=colourGratingStimulus('colour', [1 0 0 1], 'colour2', [0 1 0 1],...
	'baseColour', [0.5 0.5 0.5], 'tf', 1, 'size', 3, 'xPosition', -6, 'yPosition', 0,...
	'name', 'Red/green grating');

%%
% coherent dot stimulus; 200 dots moving at 2deg/s with coherence set to 0.25
myStims{7}=dotsStimulus('density',50,'coherence',0.25,'xPosition',4,...
	'yPosition',6,'dotType',3,'dotSize',0.1,'colorType','randomBW','mask',true,...
	'name','Coherent dots');

%%
% A simple bar: bars can be solid in colour or have checkerboard/random texture 
% (try setting 'type' to 'random' etc.). This is a bar moving at 4deg/s. 
% Notice the startPosition is -4; this means start -4 degrees "behind" X and Y position, as
% the stimulus is displayed for 2 seconds the bar therefore traverses
% 4 degrees behind then 4 degrees past the X and Y position (i.e. drift a bar over a RF location)
% Also note as we will change the angle of this stimulus the geometry is calculated for you
% automatically!
myStims{8}=barStimulus('type','checkerboard','sf',2,'barWidth',1,'barHeight',4,...
	'speed',4,'xPosition',0,'yPosition',0,'startPosition',-4,'phaseReverseTime',0.33,...
	'name','Checkerboard bar');

%%
% an edge-smoothed spot; spots can also flash if needed
myStims{9}=discStimulus('type','flash','speed',2,'xPosition',4,'sigma',40,...
	'yPosition',4,'colour',[1 1 0],'flashColour',[0 0 1],'size',3,'flashTime',[0.2 0.15],...
	'name','Flashing disc');

%%
% a picture stimulus, by default this loads a picture from the opticka
% stimulus directory; you can rotate it, scale it etc and drift it across screen as
% in this case. Size is in degrees, scaling the whole picture
myStims{10}=imageStimulus('speed',2,'xPosition',-10,'yPosition',10,'size',4,...
	'name','Image');

%%
% a picture stimulus, by default this loads a picture from the opticka
% stimulus directory; you can rotate it, scale it etc and drift it across screen as
% in this case. Size is in degrees, scaling the whole picture
myStims{11}=imageStimulus('speed',0,'xPosition',0,'yPosition',5,'size',5,...
	'fileName',[myStims.paths.root '/stimuli/star.png'],...
	'modulateColour',[0.7 0.7 0.2], 'name', 'Image');

%%
% a movie stimulus, by default this loads a movie from the opticka
% stimulus directory; you can rotate it, scale it etc and drift it across screen as
% in this case. Size is in degrees, scaling the whole movie
myStims{12}=movieStimulus('speed', 1, 'xPosition', -7, 'yPosition', -10,...
	'size', 4, 'name', 'AVI transparent movie');

%% Task Initialisation
% The taskSequence class defines a stimulus sequence (task) which is composed
% of randomised stimulus parameter changes (called variables) repeated over
% a set of blocks. A trial is an individual stimulus presentation. This
% example has three different variables changing over 3*2*2 values (12 unique trials) which is
% then repeated over 2 blocks for 24 trials in total.
%
% NOTE: for more complex behavioural tasks, Opticka uses a finite state machine to generate flexible
% experimental protocols, see stateMachine() for more details.
myTask = taskSequence(); %new taskSequence object instance
myTask.nBlocks = 2; %number of blocks
myTask.trialTime = 2; %time of stimulus display: 2 seconds
myTask.isTime = 0.25; %inter-trial time: 0.25 seconds
myTask.ibTime=0.5; %inter-block time: 1 second
myTask.realTime = true; %we use real time for switching trials, false uses a tick timer updated every flip

%% Variable 1
% Our first variable is angle, applied to 4 stimuli, randomly
% selected from values of 0 45 and 90 degrees
myTask.nVar(1).name = 'angle';
myTask.nVar(1).stimulus = [1 3 8 10 11 12];
myTask.nVar(1).values = [0 45 90];
% the next two parameters allow us to link a stimulus with
% an offset; for example you could set stimulus 1 to values [1 2 3]
% and if offsetvalue was 2 and offsetstimulus was 2 then the second
% stimulus would change through [3 4 5]; 
myTask.nVar(1).offsetstimulus = [5 6];
myTask.nVar(1).offsetvalue = 90;

%% Variable 2
% Our second variable is contrast, applied to stimuli 2 / 3 / 5, randomly
% selected from values of 0.025 and 0.1
myTask.nVar(2).name = 'contrast';
myTask.nVar(2).stimulus = [2 3 5];
myTask.nVar(2).values = [0.15 0.55];

%% Variable 3
% Our third variable is X position, applied to stimulus 2 and 7, randomly
% selected from values of -3 and 3 degrees from visual center of screen
myTask.nVar(3).name = 'xPosition';
myTask.nVar(3).stimulus = [2 7];
myTask.nVar(3).values = [-6 6];
% the next two parameters allow us to link a stimulus with
% an offset; for example you could set stimulus 1 to values [1 2 3]
% and if offsetvalue was 2 and offsetstimulus was 2 then the second
% stimulus would change through [3 4 5]; in this case we offset stimulus 10
% to +2 the values above i.e. [-4 8]
myTask.nVar(3).offsetstimulus = [10];
myTask.nVar(3).offsetvalue = 2;

%% Randomisation
% We call the method to randomise the trials in a block structure
randomiseTask(myTask);

%% Setup screenManager Object
% we initialise the object with parameter options to open the PTB screen
% with. Note distance and pixels per cm define the resultant geometry >
% pixel mappings. You can set several screen parameters, windowing,
% blending etc. hideFlash uses a trick from Mario to set the CLqUT to the
% task background colour so you don't see the black flash on PTB screen
% initialisation.
myScreen = screenManager('distance', 57.3,... %display distance from observer
	'pixelsPerCm', 36,... %calibration value for pixel density, measure using calibrateSize()
	'backgroundColour', [0.5 0.5 0.5],... %initial background colour
	'blend', true,... %enable OpenGL blending, you can also set blend modes when needed
	'debug', false,... %enable debug mode?
	'windowed', [],... %set to a widthxheight for debugging i.e. [800 600]; set to empty for fullscreen
	'bitDepth', '8bit');
if ismac; myScreen.useRetina = true; end

%% Setup runExperiment Object
% We now pass our stimulus screen and sequence objects to the
% runExperiment class. runExperiment contains the runMOC() method that actually
% runs the task.
myExp = runExperiment('stimuli', myStims,... %stimulus objects
	'task', myTask,... %task design object
	'screen', myScreen,... %screen manager object
	'debug', false,... %use debug mode?
	'verbose', false); %minimal verbosity

%%
% run our method of constants (MOC) experiment; 
% to exit early, press [q] during the interstimulus period.
opts.askForComments = false;
runMOC(myExp, opts);

%% Visual Trial List
% Lets print out a table of the stimulus properties for every trial
showTable(myTask);

%%
% Plot a timing log of every frame against the stimulus on/off times:
showTimingLog(myExp);

%%
% The image above is a graphical timing plot of every frame and whether any frames
% were dropped during stimulus presentation. This will not consider
% dropped frames during the GPU warming or inter trial time as dropped as the display is
% blank and we are using absolute time values for our trial transitions.
% Opticka actually resets and updates the stimulus objects on the second
% and subsequent frames of the inter trial blank, this forces any computation of
% stimulus parameter to when it doesn't matter; but note
% for complex stimuli a frame or two may be dropped during the blank and so
% ensure you set the inter trial time > than the dropped frames!

%% Manual control
% You don't need to use opticka's stimuli via runExperiment(), you can
% use them in your own experiments, lets have a quick look here, set
% runThis to true to run the following code:

runThis = false;
if ~runThis; return; end

% We'll use the movie stimulus, and run it on its own, using its methods
% to draw() and animate() in a standard PTB loop
WaitSecs('YieldSecs',2);
reset(myStims); % reset them back to their defaults

%stimulus
myMovie = myStims{12}; % the movie stimulus from above
myMovie.xPosition = 0; myMovie.yPosition = 0;
myMovie.speed = 5;
myMovie.size = 0; %if size is zero, then native dimensions are used.
myMovie.direction = 45; %you can specify the motion direction seperate from texture angle
myMovie.enforceBlending = false; %not needed as screen will use correct blending mode

% screen settings
myScreen.backgroundColour = [1 0 0];
myScreen.srcMode = 'GL_SRC_ALPHA';
myScreen.dstMode = 'GL_ONE_MINUS_SRC_ALPHA';
open(myScreen); %open a screen
setup(myMovie, myScreen); %setup the stimulus with the screen configuration
for i = 1:myScreen.screenVals.fps*2
	draw(myMovie);
	finishDrawing(myScreen);
	animate(myMovie);
	flip(myScreen);
end
reset(myMovie);
close(myScreen);
##### SOURCE END #####
--></body></html>